
	<<객체지향언어(Object Oriented Programming = OOP)>>
   	: 클래스를 이용해서 프로그램을 만들어 나가는 언어
   
  		<클래스>
   		: 하나의 목적을 달성하기 위해서 필요한 기능들을 모아 놓은 프로그램의 기본 단위 (클래스를 제일 먼저 만든다)
   
    EX) 문자열 관리 -> String (기본 데이터 타입x 클래스 타입)
        네트워크 처리 -> Soket
       
	클래스의 구성 요소
	   1) 변수(Field) : 필요한 데이터를 보관하고 있어야 한다.
	   2) 함수(Method) : 뭔가(필요성)를 해결하기 위한 기능이 있어야 한다.
       
		=> 이 두 가지를 합쳐서 멤버(Member)라고 부른다. (클래스 바로 아래에는 멤버 제외한 일반명령은 올 수 없다.)      
  		
 	클래스 제작 방법
 		1) 형식 : 접근지정자  [속성](//생략가능)  class	클래스이름 {
 					변수 선언;
 					변수 선언;
 					
 					함수 선언;
 					함수 선언;
 		           }	
 		           
 ********중요한 점 *******
 클래스는 설계도에 불과하다. (붕어빵 틀)
 즉, 클래스만 가지고 있다고 해서 이것이 실행되는 것이 아니다.
 반드시 클래스가 실행 가능한 물건으로 만들어져야(메모리에 올려진 상태) 실행할 수 있다. 
 
  Object(객체) = Reference(변수) + Instance(인스턴스)
  
  결국, 객체지향언어는 클래스를 기반으로 해서 만들어지는, Object에 의해서 만들어지는 프로그램
  이미 만들어져 있는 건 가져다 쓰거나 조금 수정하고, 없는 건 내가 만드는 게 객체지향언어 
  개발자가 전부 코딩하지 않고 부품별로 코딩해서 필요한 순간에만 가져다 조립해서 쓴다. 
  
  
  
  +) 자바는 메모리에 올려진 것들의 주소를 알아야 사용할 수 있다.
  이 역할을 하는 것이 변수
  틀은 같아도 담겨진 내용은 다를 수 있다.
  
  메모리에 올려져 있는 클래스 = 객체

----------------------------------------------------------------------------------------------------------------------------------------------

	객체(Object)를 만드는 방법
	: 객체는 JVM이 만든다. 
	  개발자는 필요한 부품을 만들어 달라고 JVM에게 명령만 내린다.
	   
	 1) 형식 : 클래스이름 변수;
	 			변수 = new 클래스이름();
	 			
	      ex) Test라는 클래스가 있다면?
	          
	          Test t; --> t는 레퍼런스 변수가 된다.
	          			  이 변수의 Heap Type은 Test가 된다.
	          
	          t = new Test(); --> new 명령을 통해 클래스가 Object가 된다. 컴퓨터가 물건을 만든다는 개념은 메모리에 클래스가 만들어진다는 개념과 같다.
	 			 -인스턴스-
	 		  - 객  체 --  
	 		  
	 		  따라서 Heap에 만들어진 클래스를 Instance라고 부르고, 만들어진 Instance의 주소를 기억할 변수를 Reference라고 부른다.
	 		  이 두 개를 통칭해서 Object(객체)라고 한다.      
	          
	          +) 메모리에 올려놓아야 프로그램이 실행 가능해진다. 
	          
	          ex) class Test {
	          		int a;
	          		int b; --> 
	          		void abc(){} --> 독립적으로 호출할 수 없고 Test가 메모리에 올려져야만 사용할 수 있는 함수. 즉, 메소드
	          		void xyz(){}
	               }			
	          	
	          	  ==> 하드에 저장돼 있는 소스코드일 뿐
	          	  
	              객체로 만들기 위해서는
	              
	              Test t;
	              t = new Test();

--------------------------------------------------------------------------------------------------------------------------------------------------

	객체를 사용하는 방법
	: 객체를 사용한다는 개념은 그 목적을 달성하기 위해서 필요한 데이터를 기억하거나, 필요한 함수를 호출(이용)하는 것	
	
	1) 형식 : 주소.변수; or 주소.함수(데이터); // 주소 = 변수 (t), 
	
		ex) Test 클래스의 a 변수에 10을 기억시킨다.
			Test t;
			t = new Test();
			t.a = 10;
			+ 함수 실행?
			t.abc();
			
	+) 함수로딩
	1. 함수 이름이 같아야
	2. 매개변수 순서 형태 개수 달라야
	3. 반환값과 노상관

          *****참고*****
          	클래스 하나당 Object는 여러 개 만들어도 상관없다.
            즉, 설계도는 한 장만 있으면 되는데 설계도 한 장으로 물건은 여러 개 만들 수 있다.
			이 때 주소를 이용해서 사용하게 되므로 
			
			ex)  Test t = new Test();
				 Test t2 = new Test();
				 
				 toPrint()가 멤버 변수 a의 내용을 출력해주는 기능이라고 가정할 경우
				 t.a = 10;
				 t2.a = 1000;
				 
				 t.toPrint(); ==> 10 출력
				 t2.toPrint(); ==> 1000 출력
			
			따라서 각각의 객체는 별개로 독립되어서 실행될 수 있다.

  <참고>
  
 	지역변수 : 해당 지역에서만 사용할 수 있는 변수, 그 코드가 실행되는 순간 변수가 만들어지고 그 블럭을 벗어나면 그 변수는 사라짐
 			   
 	전역변수 : 모든 지역에서 사용할 수 있는 변수, 프로그램이 종료되지 않는 이상 계속 쓸 수 있다.
	            클래스 안에서 만들어진 변수는 new 시키는 순간 Heap 영역에 만들어지기 때문.
	            Heap 영역의 특성에 따라서 계속 사용할 수 있게 된다.	(공간이 아주 크다, 모자라면 다른 곳에서 가져다 쓴다, 알아서 지운다.)
	            
	            인스턴스의 
	            탄생시점 : new 시키는 순간
	            소멸 시점 : 프로그램이 종료되는 순간

=======================================================================================================================================================
	
	객체의 배열
		: 하나의 클래스(붕어빵 틀)를 가지고 여러 개의 객체(붕어빵)를 만들 수 있으므로 
		  이 때 만들어진 객체들을 배열로 만들어서 관리할 수 있다. (변수 여러 개 만들지 않아도 됨)
		
	만드는 방법 
	 	: Test[] t; -> Test 인스턴스들을 배열로 관리할 주소 변수 만든다.
	 	  t = new Test[갯수]; -> 관리할 갯수를 정해서 배열을 만든다.
	 	  
	 	  ****주의****
	 	  아직 실질적인 객체는 만들어놓지 못한 상태.
	 	  
	 	  class Test {
	 	  		int a;
	 	  }
	 	  
	 	  Test[] t = new Test[5]; --> Test 타입의 객체를 관리할 공간만 확보한 상태
	 	  
	 	  t[0].a -->이렇게 접근해서 a 변수에 기억된 숫자를 꺼내오지 못한다. 채워진 데이터가 없는 null 상태
	 	  
	 	  따라서 
	 	  	for(int i = 0 ; i < 5 ; i++) {
	 	  			t[i] = new Test();
	 	  	}	 	  	 
			위 작업으로 실제 오브젝트를 만들어서 채워줘야 한다.
			
	     사용 방법 
	     	: 배열변수[위치값].변수이름 = 데이터이름;	            
	     	: 배열변수[위치값].함수이름();	            
				
			  배열변수[위치값] 안에 있는 주소는 오브젝트 참조 주소이기 때문에 "."을 이용해서 접근해야 한다.
			  즉, 소속을 밝혀줘야 한다.

-------------------------------------------------------------------------------------------------------------------------------------------------

	함수의 오버로딩(OverLoading : 함수의 중첩)
 	: 함수 이름을 중첩해서 만든다는 의미
 	  
 	  원칙적으로는 한 클래스 안에서 함수의 이름은 모두 달라야한다. 
 	  같은 이름의 함수가 존재하면 오류가 발생한다.
 	  이러다보니 가독성에 있어서 문제가 발생	
 	  즉, 가독성이란 함수의 이름만 봐도 그 기능을 알 수 있어야 함을 의미
 	  함수의 이름을 모두 다르게 만들면 가독성이 떨어질 수밖에 없음
 	  이를 해결하기 위해서 도입된 문법이 함수의 오버로딩

	  오버로딩이란 같은 클래스 안에 같은 이름의 함수를 만들 수 있게 해주는 것
	  
	  조건 0. 해당 클래스에 오버로딩 하려는 함수가 있어야 한다. 
	       1. 함수의 이름이 같아야 함 
	  	   2. 매개변수의 갯수, 순서, 형태 중 하나 이상이 달라야 함
	  	   3. 반환값과는 상관없다.
	  	   
	  	   EX) void abc(){}
	  	   	   void abc(int a){}  ==> (o)	  
 	  		   
 	  		   void xyz(int a){}
 	  		   void xyz(float a){} ==> (o)
 	  		   
 	  		   void lmn(int a, float b){}
 	  		   void lmn(float b, int a){} ==> (o)
 	  		   
 	  		   int efg(){}
 	  		   void egf(){} ==> (x) / 반환값과는 상관없기 때문에
 	  		   
 	  		   void hij(int a, int b){} 
 	  		   void hij(int b, int a){} ==> (x) / 입력되는 타입이 동일하므로 같은 형태로 취급
 	  		   
 	  		   결론적으로 함수를 호출할 때 정확한 함수를 선택할 수 있도록 해야 한다.	
 			  	원래 함수의 오버로딩 규칙

     <사용법>
     	다른 사람이 만든 클래스에도 오버로딩이 구현된 함수를 볼 수 있다.
     	이 함수들을 사용하는 방법은 원하는 기능을 하는 함수가 요구하는 데이터를 형태와 순서에 맞춰서 정확하게 입력해주는 것
     	
			  
            		               	  
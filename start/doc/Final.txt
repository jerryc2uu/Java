==========================================================================================================================================

day09



 함수(Method, Function) 
		
 1. 정의
 	한 가지 작업을 실행하기 위해 만들어진 가장 작은 단위의 프로그램.
 	즉, 기능의 최소 단위.
 	
   ++) 프로그램이란?
 	이런 함수들이 모여서 원하는 목적을 이루도록 구성하는 것. 
 	자바에서는 클래스 단위로 프로그래밍을 함. 이 클래스 안에 함수가 차곡차곡 쌓인다.
 	(자바에서 클래스가 가질 수 있는 건 변수(데이터 기억)와 함수(데이터 가공))
 	
 	
 	
 2. ***특징***
   	
   	1) 함수는 누군가 호출해야만 실행된다. 함수 스스로가 실행되는 경우는 없다. 메인함수 역시 JVM이 호출
   	
   	2) 함수는 실행이 완료되면 자신을 호출한 곳으로 실행 순서를 넘긴다.
   	   
   	  ex1 ) class Test {
   	   		static void abc(){
   	   			(1)
   	   		}	
   	   		public static void main(String[] args){
   	   			(2)
   	   			abc();
   	   			(3)
   	   		}
   	   		
   	   		static void xyz(){
   	   			(4)
   	   }	
   	   
   	   
   	   ==> (2) - (1) - (3) - 종료  (4)는 호출하지 않은 것		
   	   
   	   ex2 ) class Test {
   	   		static void abc(){
   	   			(1)
   	   			xyz();
   	   			(2)
   	   		}	
   	   		public static void main(String[] args){
   	   			(3)
   	   			abc();
   	   			(4)
   	   		}
   	   		
   	   		static void xyz(){
   	   			(5)
   	   }
   	   
   	   ==> (3) - (1) - (5) - (2) - (4) - 종료
   	   
   	  
 3. 함수 만드는 방법
 	
 	1) 형식
 		: 접근지정자   [속성]   반환값타입    함수이름(매개변수) { 함수내용 }
 		
 	2) 속성
 		- final : 변수에 final이 붙으면 입력한 데이터 수정 불가 = 상수 (snake 표기법으로 대문자로 변수 이름 표기, 변수 선언 시 초기화도 같이 해야 함.)
 		- static : 변수, 함수에 붙음. 스태틱 영역에 미리 올려짐. 스태틱 멤버만 호출할 수 있음.
 		- abstract
 		....
 			
 	3) 접근 지정자 : 해당 개체에 접근할 수 있는 권한을 지정해놓은 것
 		
 	4) 함수 이름 : 개발자가 지정하는 사용자 정의어
 	
 	5) 매개변수 리스트 : 변수 선언 형태로 만드는 것, 갯수와는 상관이 없음 (함수와 호출한 곳의 매개 역할)	
 						
 						==> 함수가 원하는 작업을 하기 위해서 반드시 필요한 데이터가 있을 것이다. (두 수를 합해야 한다 -> 두 수는 반드시 필요)
 							이 데이터를 기억할 준비를 하는 것이다. 		
 	
 	6) 반환값 타입 : 함수가 어떤 작업을 실행한 결과를 알려주는 것 (1개 or 없음)
 					 
 					 ex) println - 콘솔 화면 출력 vs math.random - 난수 발생

 					 - 결과 있음 : 결과 타입만  ex) plus 함수 -> int  	
 					 - 결과 없음 : void         ex) println

 					 
 					  
 	
 4. 형태
 		
 	1) void abc() {} : 반환값 없고 매개변수 없음 
    2) int abc() {} : 반환값 있고 매개변수 없음
    3) void abc(int no) {} : 반환값 없고 매개변수 있음
 	4) int abc(int no) {} : 반환값 있고 매개변수 있음
 				
 		
 		


  5. return 명령
  
  	: 함수 안에서 사용할 수 있는 명령  ex) break, countinue과 같은 맥락 (반복문에만 적용되는 명령)
 
   1) 의미 
  	- 함수 실행을 종료하라 (return;)
  	- 결과가 있다면 결과를 내보내고 함수 실행을 종료하라 (return 데이터;)
  	
   2) 형식
  	- return; : 함수 실행을 종료
  	- return 데이터; - 데이터 반환해주고(이 함수를 실행한 위치에 데이터를 내보내주고) 실행 중인 함수를 종료하라
  		
 	<참고>
 		- 반환값이 void(없음)인 경우는 반드시 return;만 사용할 수 있다. return; 생략도 가능
 			-> 함수의 내용이 다 실행되면 블럭이 닫히고 함수가 자동 종료되기 때문
 				
 		- 반환값이 void 아닌 경우(있음)는 반드시 return 데이터;만 사용할 수 있다.
 		

  
  6. 함수의 사용 방법 : 함수는 반드시 호출해야만 사용할 수 있다. 따라서 함수를 사용한다는 것은 그 함수를 호출한다는 의미
  					 
  
     1) 형식 : 함수이름(데이터, ...//매개변수 리스트와 갯수 같아야 함); 		
 		
 		++) 데이터(파라미터, Parameter)란?
 		
 			 함수가 준비하고 있는 매개변수 리스트에 기억할 정보를 제공하는 것
 			 데이터는 그 함수가 준비한 매개변수의 갯수, 형태, 순서와 반드시 일치해야 한다.
 		
  			ex) void abc(int a){}
  				--> abc(); (x) 데이터 입력이 안 됐음
  					abc(5); (o) 
  					abc(3.4); (x) 데이터 형태가 다름
  					abc(3, 4); (x) 데이터 갯수가 다름	
 		
 		
   					
 
 
 
  7. 반환값 사용 방법 
 					   
 		                ex) int abc(){
 					   		int k = 5;
 					   		return k;
 					       }	
 		
 						   void xyz(int a){}	
 							
 						   int lmn(int a){
 						      ...
 						      return ??;
 						   }
 						   
 						   abc(); --> (o)
 						   
 						   int a = abc(); --> (o)
 						   
 						   System.out.println(abc()); --> (o)
 						   
 						   xyz(abc()); = xyz(5);와 동일 --> (o)
 						   
 						   abc(lmn()); --> (x) 데이터 입력해서 실행하는 abc 함수는 만들어놓지 않았기 때문
 		
 		
					   참고 : 반환값이 있는 함수라도 필요하지 않으면 반환값을 이용하지 않아도 상관 없다.	 								
 		 
 8. 함수의 오버로딩 (함수의 중첩) : 같은 이름으로 함수를 한 클래스 내에 추가하는 방법
		 	<원칙> 
		 	0. 함수에 오버로딩하려는 함수가 있어야 한다.
		 	1. 함수 이름이 같아야 한다.
		 	2. 매개변수 리스트가 달라야 한다.(매개변수 리스트의 타입, 순서, 갯수 중 하나 이상이 달라야 한다.)
		 	3. 반환값 타입과는 무관하다. 반환값 타입은 다르게 써줘도 된다는 뜻 
		 	
		 	<참고>
		 	void abc(int a, int b){}
		 	void abc(int b, int a){} (x) 매개변수 리스트의 형태는 데이터 타입으로 판별한다.
  
  
  
  
  
  객체지향언어(Object Oriented Programming = OOP)	
   
   : 클래스를 이용해서 프로그램을 만들어 나가는 언어
   
  	클래스
   		: 하나의 목적을 달성하기 위해서 필요한 기능들을 모아 놓은 프로그램의 기본 단위 (클래스를 제일 먼저 만든다)
   
    EX) 문자열 관리 -> String (기본 데이터 타입x 클래스 타입)
        네트워크 처리 -> Soket
       
	클래스의 구성 요소
	   1) 변수(Field) : 필요한 데이터를 보관하고 있어야 한다.
	   2) 함수(Method) : 뭔가(필요성)를 해결하기 위한 기능이 있어야 한다.
       
		=> 이 두 가지를 합쳐서 멤버(Member)라고 부른다. (클래스 바로 아래에는 멤버 제외한 일반명령(print 등)은 올 수 없다.)      
  		
 	클래스 제작 방법
 		1) 형식 : 접근지정자  [속성](//생략가능)  class	클래스이름 {
 					변수 선언;
 					변수 선언;
 					
 					함수 선언;
 					함수 선언;
 		           }	
 		           
 ********중요한 점 *******
 클래스는 설계도에 불과하다. (붕어빵 틀)
 즉, 클래스만 가지고 있다고 해서 이것이 실행되는 것이 아니다.
 클래스는 하드에 저장돼 있으나 저절로 실행되진 않는다.
 반드시 클래스가 실행 가능한 물건으로 만들어져야(메모리에 올려진 상태, 실제 붕어빵) 실행할 수 있다. 
 
 
 객체 
   : 메모리에 올려져 있는 클래스
 
 
 Object(객체) = Reference(변수) + Instance(인스턴스)
  
 객체지향언어 
   : 클래스를 기반으로 해서 만들어지는, Object에 의해서 만들어지는 프로그램
   
	 램에 올려놓고 필요할 때마다 꺼내쓰는 게 객체지향언어    

  이미 만들어져 있는 건 가져다 쓰거나 조금 수정하고, 없는 건 내가 만드는 게 객체지향언어 
  개발자가 전부 코딩하지 않고 부품별로 코딩해서 필요한 순간에만 가져다 조립해서 쓴다. 
  
  
  
  +) 자바는 메모리에 올려진 것들의 주소를 알아야 사용할 수 있다.
  이 주소를 기억하는 것이 변수
  틀은 같아도 담겨진 내용은 다를 수 있다.
  
  메모리에 올려져 있는 클래스 = 객체


	객체(Object)를 만드는 방법
	: 객체는 JVM이 만든다. 
	  개발자는 필요한 부품을 만들어 달라고 JVM에게 명령만 내린다.
	   
	 1) 형식 : 클래스이름 변수;
	 			변수 = new 클래스이름();
	 			
	      ex) Test라는 클래스가 있다면?
	          
	          Test t; --> t는 레퍼런스(변수)가 된다.
	          			  이 변수의 Heap Type은 Test가 된다. (String과 같은 것)
	          
	          t = new Test(); --> new 명령을 통해 클래스가 Object가 된다. 컴퓨터가 물건을 만든다는 개념은 메모리에 클래스가 만들어진다는 개념과 같다.
	 			 -인스턴스-
	 		  - 객  체 --  
	 		  
	 		  따라서 Heap에 만들어진 클래스를 Instance라고 부르고, 만들어진 Instance의 주소를 기억할 변수를 Reference라고 부른다.
	 		  이 두 개를 통칭해서 Object(객체)라고 한다.      
	          
	          +) 메모리에 올려놓아야 프로그램이 실행 가능해진다. 
	          
	          ex) class Test {
	          		int a;
	          		int b; 
	          		void abc(){} --> 독립적으로 호출할 수 없고 클래스가 객체가 되어야지만(Test 클래스가 메모리에 올려져야만) 사용할 수 있는 함수. 즉, 메소드(클래스에 소속돼 있는 함수)
	          		void xyz(){}
	               }			
	          	
	          	  ==> 하드에 저장돼 있는 소스코드일 뿐, 붕어빵 틀일 뿐
	          	  
	              객체로 만들기 위해서는
	              
	              Test t;
	              t = new Test();



	객체를 사용하는 방법
	
	: 객체를 사용한다는 개념은 그 목적을 달성하기 위해서 필요한 데이터를 기억하거나, 필요한 함수를 호출(이용)하는 것	
	
	1) 형식 : 주소.변수;
	          주소.함수(데이터); // 주소 = 변수 (t), 
	
		ex) Test 클래스의 a 변수에 10을 기억시킨다.
		
			Test t;
			t = new Test(); // 주소(레퍼런스 변수) 기억시킨 상태
			
			t.a = 10; // a 변수에 10 기억
			   + 함수 실행?
			t.abc();
			
			

          *****참고*****
          	클래스 하나당 Object는 여러 개 만들어도 상관없다.
            즉, 설계도는 한 장만 있으면 되는데 설계도 한 장으로 물건은 여러 개 만들 수 있다.
			클래스 안에서 만들어진 변수는 new 시키는 순간 Heap 영역에 만들어지기 때문.
			Heap 영역의 특성에 따라 계속 사용할 수 있음
			
			이 때 주소를 이용해서 사용하게 되므로 
			
			ex)  Test t = new Test();
				 Test t2 = new Test(); // 객체 두 개 만들기 가능
				 
				 toPrint()가 멤버 변수 a의 내용을 출력해주는 기능이라고 가정할 경우
				 t.a = 10;
				 t2.a = 1000;
				 
				 t.toPrint(); ==> 10 출력
				 t2.toPrint(); ==> 1000 출력 // 멤버를 공유하지 않음
			
			==> 따라서 각각의 객체는 별개로 독립되어서 실행될 수 있다.

  <참고>
  
 	지역변수 : 해당 지역에서만 사용할 수 있는 변수, 그 코드가 실행되는 순간 변수가 만들어지고 그 블럭을 벗어나면 그 변수는 사라짐
 			   
 	전역변수 : 모든 지역에서 사용할 수 있는 변수, 프로그램이 종료되지 않는 이상 계속 쓸 수 있다.
	            클래스 안에서 만들어진 변수는 new 시키는 순간 Heap 영역에 만들어지기 때문.
	            Heap 영역의 특성에 따라서 계속 사용할 수 있게 된다.	(공간이 아주 크다, 모자라면 다른 곳에서 가져다 쓴다, 알아서 지운다.)
	            
	            인스턴스의 
	            탄생시점 : new 시키는 순간
	            소멸 시점 : 프로그램이 종료되는 순간


	
	객체의 배열
	
		: 하나의 클래스(붕어빵 틀)를 가지고 여러 개의 객체(붕어빵)를 만들 수 있으므로 
		  이 때 만들어진 객체들을 배열로 만들어서 관리할 수 있다. (변수 여러 개 만들지 않아도 됨)
		
		
	만드는 방법 
	 	: Test[] t; -> Test 타입의 객체들을 관리할 배열의 주소 변수 t를 만든다.
	 	  t = new Test[갯수]; -> 관리할 갯수를 정해서 배열을 만든다.
	 	  
	 	  ****주의****
	 	  ==> 아직 실질적인 객체는 만들어놓지 못한 상태. 객체를 넣을 공간만 확보한 상태.
	 	  
	 	  
	 	  class Test {
	 	  		int a;
	 	  }
	 	  
	 	  Test[] t = new Test[5]; --> Test 타입의 객체를 관리할 공간만 확보한 상태
	 	  
	 	  t[0].a -->이렇게 접근해서 a 변수에 기억된 숫자를 꺼내오지 못한다. 채워진 데이터가 없는 null 상태, new 안 시킨 상태
	 	  
	 	  따라서 
	 	  	for(int i = 0 ; i < 5 ; i++) {
	 	  			t[i] = new Test();
	 	  	}	 	  	 
			위 작업으로 실제 오브젝트를 만들어서 채워줘야 한다.


			
	     사용 방법 
	     	: 배열변수[위치값].변수이름 = 데이터이름;	            
	     	: 배열변수[위치값].함수이름();	            
				
			  배열변수[위치값] 안에 있는 주소는 오브젝트 참조 주소이기 때문에 "."을 이용해서 접근해야 한다.
			  즉, 소속을 밝혀줘야 한다.



	함수의 오버로딩(OverLoading : 함수의 중첩)
 	: 함수 이름을 중첩해서 만든다는 의미
 	  
 	  원칙적으로는 한 클래스 안에서 함수의 이름은 모두 달라야한다. 
 	  같은 이름의 함수가 존재하면 오류가 발생한다.
 	  이러다보니 가독성에 있어서 문제가 발생	
 	  즉, 가독성이란 함수의 이름만 봐도 그 기능을 알 수 있어야 함을 의미
 	  함수의 이름을 모두 다르게 만들면 가독성이 떨어질 수밖에 없음
 	  이를 해결하기 위해서 도입된 문법이 함수의 오버로딩

	  오버로딩이란 같은 클래스 안에 같은 이름의 함수를 만들 수 있게 해주는 것
	  
	  조건 0. 해당 클래스에 오버로딩 하려는 함수가 있어야 한다. 
	       1. 함수의 이름이 같아야 함 
	  	   2. 매개변수의 갯수, 순서, 형태 중 하나 이상이 달라야 함
	  	   3. 반환값과는 상관없다.
	  	   
	  	   EX) void abc(){}
	  	   	   void abc(int a){}  ==> (o)	  
 	  		   
 	  		   void xyz(int a){}
 	  		   void xyz(float a){} ==> (o)
 	  		   
 	  		   void lmn(int a, float b){}
 	  		   void lmn(float b, int a){} ==> (o)
 	  		   
 	  		   int efg(){}
 	  		   void egf(){} ==> (x) / 반환값과는 상관없기 때문에
 	  		   
 	  		   void hij(int a, int b){} 
 	  		   void hij(int b, int a){} ==> (x) / 입력되는 타입이 동일하므로 같은 형태로 취급
 	  		   
 	  		   결론적으로 함수를 호출할 때 정확한 함수를 선택할 수 있도록 해야 한다.	
 			  	원래 함수의 오버로딩 규칙

     <사용법>
     	다른 사람이 만든 클래스에도 오버로딩이 구현된 함수를 볼 수 있다.
     	이 함수들을 사용하는 방법은 원하는 기능을 하는 함수가 요구하는 데이터를 형태와 순서에 맞춰서 정확하게 입력해주는 것
     	
     	
=====================================================================================================================================================================================
#day10

+) 속성은 static만 함, static 영역에 먼저 올려지는 멤버들. JVM이 확보한 영역

<접근지정자> - 클래스, 함수 등에 쓰임
 : 그 내용을 어디까지 사용할 수 있는지 지정하는 예약된 용어
 
 개발자가 클래스를 제작한다고 해서 그 클래스(내용)가 모든 사람에게 공개되게 하는 것은 아님
 이런 경우 클래스를 제작하는 사람이 사용범위를 지정할 수 있음
 
 ex) class는 누구까지 이 클래스를 사용하도록 할 것인가?
 	 new 시킬 수 있도록 할 것인가?
 	 어디까지 이 함수를 호출할 수 있도록 할 것인가?
   
   종류 : (*****암기*****)
   	
   	 1) public : 모든 곳에서 사용 가능
   	 
   	 2) protected : 상속받은 하위 클래스 + 같은 패키지 소속의 클래스들에서만 사용 가능 
   	 
   	 3) 생략된 경우 : 같은 패키지 소속의 클래스들까지만 사용 가능
   	 
   	 4) private : 다른 클래스에서는 절대 사용 불가능, 오직 자기 자신의 클래스 내에서만 사용 가능
   	 
   참고 : class는 지정할 수 있는 접근지정자가 public과 생략 두 가지 뿐.
   

	객체지향언어의 특징
	
	1. 상속
	
	2. 다형성 
	
	3. 은닉화/캡슐화 ***
	 
	 프로그램에 있어 가장 중요한 요소는 데이터.
	 즉, 프로그램에서는 데이터를 기억하고 있는 변수가 핵심적인 요소
	     +) 함수는 데이터 가공만 함, 데이터 자체를 기억하지는 못함. 함수는 기능만 하고 데이터는 변수가 가지고 있음
	 무결성(결함이 없는 성질-이를 위해 db 사용) 데이터를 유지하는 것이 가장 중요한 개념
	 
	 은닉화
	  : 이처럼 중요한 요소인 변수를 일반 사용자들이 함부로 변경하지 못하도록(결점 있는 데이터가 들어오지 못하도록 하는 것)
	 방지하는 기법을 의미 
	 
	    방법 
	       1. 중요한 데이터가 기억될 변수의 접근지정자를 private으로 지정
	       	  ==> 그 변수는 다른 사용자가 사용할 수 없게 됨
	       	  
	       2. 대신 변수의 데이터를 변경하거나, 값을 꺼내올 수 있도록 함수를 만들어놓는다.
	       
	    
	 
	 ex) 생일을 입력하세요.
	 		형식은 2002년 03월 08일으로 입력하세요.
	 		    
		 사용자 입력 : 02/03/08	 
		 이 경우 생일데이터에 결함이 생기게 된다.







	<생성자(Constructor)>  : 객체 만들 때 호출되는 함수

	  
	  1. 형식
	 
	   	     1. 함수의 이름 = 클래스 이름 
	    	 
	    	 2. 반환값 x
	    	 
	    	 3. 매개변수 o
	    	 	
	    	 	
	    	 	ex) String str = new String("나는 문자열");
	    	 		String str2 = new String();
	    	 		
	    	    ex) class Test { 
	    	    		public Test(){ ==> 매개변수가 없는 기본 생성자
	 						 
	    	    		}
	    	    		
	    	    		public Test(int a){} 
	    	    		public Test(String name){}
	    	        }		
	    	        
	    	        이 클래스를 객체로 만들 때 여러 방법이 있음
	    	        
	    	        new Test();   ==> 기본 생성자
	    	        
	    	        new Test(10);
	    	        
	    	        new Test("제니");
	 						 
	 						  
	    	
	     +) 매개변수가 있는 생성자를 호출하기 위해서는  new 시킬 때 매개변수가 필요한 데이터를 주면서 new 시키면 된다.
	     
	     
	  
	    	        
	    	        
	 2. 사용법
	 
		: 생성자가 요구하는 매개변수에 따라 호출
			        
	    	        
	    
	    
	    
	<this()> : 현재 생성자를 실행하는 도중에 다른 생성자를 강제로 호출하는 유일한 방법
	    
	    	 +) this. : 현재 실행중인 객체 자신의 주소를 기억하는 변수
	    			
	    			   
	    	규칙 (암기)
	    		
	    		1) 생성자 안에서만 사용 가능   
	    		
	    		2) 생성자 내 첫 문장 첫 명령으로만 사용 가능
	    		
	    		
	    	이유
	    		
	    		: 생성자끼리의 역할은 비슷하기 때문에 중복을 피하기 위해
	    		  


	<가변인자>
	
	: 데이터 갯수가 정해지지 않은 상태에서 쓰는 매개변수
	  	
	
	
	  형식 : 접근지정자   반환값타입   함수이름(변수타입...변수이름){}  	        

	    ex) public void pirntSum(int ... n){}	      
	    	        
	    	        
	    	        
	  사용법

	   	 1) 가변인자로 정의된 매개변수는 자동 배열변수가 된다. 따라서 입력된 데이터를 다룰 때는 배열처럼 사용해야 한다.
	 
	   	 
	   	  배열 변수 선언 시 - int[] num; - num 변수에는 정수 배열은 모두 기억시킬 수 있음, 길이는 상관 무 ==> 이것과 마찬가지
	   	  
	    
         2) 가변인자 앞에는 다른 매개변수가 와도 상관 무, 뒤에는 오면 안 됨
         
	    	ex) public void pirntSum(int ... n, float f){} --> (x)	      
         	     		  
	 
==============================================================================================================================================
##day11

	<this>  : 현재 실행 중인 객체의 주소를 기억하는 약속된 변수 
 	
   
  		 규칙
  		 	    1. 모든 멤버는 앞에 주소가 있어야 한다.
   			       
   				2. 주소를 적지 않으면 JVM이 자동적으로 this를 붙여준다.
   			  
   		     	3. 멤버 함수 호출 시 주소값을 함수에게 알려줘야 함
   		
   			

   
   
   	<static 속성>  :  static 영역에 생기는 함수나 변수에 붙여줌
   	  
   	 	+) 클래스, 함수, 변수를 만들 때 속성을 지정할 수 있음
   		
   		 ex) 접근지정자    (속성)   class    클래스이름    {}
   		 	 접근지정자    (속성)   반환값타입     함수이름(매개변수 리스트)   {}
   		 	 접근지정자    (속성)   데이터타입     변수이름;
   		 	 
   	   
   	  *	 1. 특징
   	   
   	   		1) 자동으로 생김
   	   	 
   	   		2) 한 번 생긴 변수나 함수는 두 번 다시 생기지 않는다.
   	   		
   	   		3) this 사용 불가
   	   
   	   
   	  	 2. static 변수 : static 영역에 만들어지는 변수
   	    
   	    	
   	    	
   	    	형식 =    접근지정자     static    (다른 속성)    데이터타입    변수이름; 
   	    
   	    	ex) public static final int BLACK = 1004;
  			 	    
			
			
			
			특징   	    	

   	    	  - 여러 객체가 공동으로 사용 
   	    			
   	    	  - new 시키지 않아도 사용 가능
   	    		


   	        사용방법
		   	        	
		   	        	클래스이름.변수이름;
		   	        	
		   	        
		   	    ++) static 멤버에는 this를 붙일 수 없다.
   	    		 	
   	    		 	
   	    		 	
   	    
   	    
   	    
   	    
   	     3. static 함수 : static 영역에 만들어지는 함수 (객체를 만들지 않아도(new 시키지 않아도) 사용할 수 있는 함수)
   	     	  
   	     	 
   	     	 형식 = 클래스이름.함수이름(데이터);
   	     	 
   	     	 
   	     	 특징
   	     	 	- this 사용 불가
   	     	 
   			  +) static 함수 안에서는 메모리에 올려진 것들만 사용 가능
   	    		 일반함수 안에서는 static 멤버 그리고 일반 멤버도 사용 가능
   	     
   	     
   	     
   	     
   <멤버 변수의 초기화>
  
  	: 멤버 변수는 Heap 영역에 생기므로 자동 초기화가 된다. (기본 데이터 타입 = 0, 참조형 = null)
  	  하지만 가끔은 변수에 기본적인 값을 지정할 필요가 있다.
     
     방법
     	1) 명시적 초기화
     	   : 변수 선언하면서 값을 대입하는 것
     	     가장 먼저 실행되는 방법
     	     
     	     ex) class Test {
     	     		int no = 10; // 명시적 초기화
     	     	 }
     	
     	2) 초기화 블럭 이용한 초기화
   			: 인스턴스 변수에 한해서만 가능한 방법 
   			  두 번째로 실행되는 방법
   			  
   			 ex)  class Test{
					int no;
   			        {
   			              no = 100;
   			        }
   			      }        
   			            	
     	3) static 블럭 이용한 초기화
     	 	: 2번과 마찬가지로 static 변수에 한해서만 가능한 방법
     	 	  두 번째로 실행되는 방법
     	 	  
     	 	  static { 
     	 	  			데이터입력
     	 	  		}
     	 	  		
     	 	  ex) class Test {
     	 	  		static int no;
     	 	  		
     	 	  		static {
     	 	  			no = 100;
     	 	  	 	}
     	 	  	 }
     	 	  
     	
     	4) 생성자 이용한 초기화  	 	     
   	     	 : 가장 마지막에 실행되는 방법
   	     	 
   	     	 ex) class Test {
   	     	 		int no;
   	     	 		
   	     	 		public Test() {
   	     	 			no = 100; // 생성자 이용한 초기화
   	     	 		}
   	     	     }    
   	     	     


	<객체지향언어의 특징>
		
		1. 상속
		2. 다형성
		3. 은닉화 / 캡슐화
 
	
	<상속>
		
		: 하위 클래스에서 상속 클래스의 멤버를 수정하는 방법
		  
		  
		  형식  
		  	
		  	:  접근지정자   (속성)   class   클래스이름    extends   복사해올클래스이름 {}
		  
		  
		* 특징
		  
		   - 단일 상속만 가능 
		     	 
		    ex) class NewClass extends Old1, Old2 {}  ==> (x) 
				class NewClass extends Old1 {}  ==> (o)
		
		  	
		 
			is a = 하위 클래스 is a 상위 클래스
			
					class Father {}
					class Son extends Father {}
					
					==> Son is a Father가 성립된다.
					
					Father f = new Son(); ==> (o)
					Son s = new Father(); ==> (x) 
						Son s = (Son) new Father();
						
			has a = 어떤 클래스 안에 다른 클래스를 멤버로 가지고 있는 상태
					
					class Father {}
					class Son {
						Father f = new Father();
					}
					
					==> Son has a Father가 성립된다.
					
	
		상속 관계에 있는 경우 생성자의 역할
		
			: 하위 클래스를 new 시키는 순간 상위 클래스의 객체가 자동 생성되며 기본 생성자가 자동 호출된다.	
			 
		
		 
	*	super() : 현재 클래스의 생성자 함수에서 상위 클래스의 생성자를 호출하는 유일한 방법
				  
				
			
			특징 
				
				1) 반드시 생성자 함수 안에서만 사용 가능
				
				2) 반드시 첫 줄 첫 문장으로만 사용 가능
				
				
					  	
			ex) class Father {
			 		int no;
			 		public Father() {
			 		
			 		}
			 		public Father(int no) {//오버로딩한 생성자 함수
			 			this.no = no;
			 		}
			    } 
			    
			    class Son extends Father {
			    	char ch;
			    	
			    	public Son() {}
			    	public Son(int no, char ch){//오버로딩한 생성자 함수
						super(5); // 상위 클래스 객체의 no가 하위 클래스의 5로 셋팅된다.
						this.ch = ch;
					}		    	
			    }
				
				
	
	<함수의 오버라이딩(Overriding, 재정의)>
	 : 상속 관계에 있는 하위 클래스에서 상위 클래스가 가지고 있는 함수의 기능을 수정하는 행위
	 			
				
		방법
		  
		  0) 상위 클래스의 함수가 존재해야 한다.
		  
		  1) 상위 클래스가 가진 함수의 원형(prototype)과 동일한 원형으로 만들어야 한다.
		  			
				함수의 원형(prototype) = 반환값 + 함수이름 + 매개변수 리스트
				
		  2) 접근지정자는 같거나 넓은 방향으로 기술
		  		
		  		ex) 생략 ==> 3가지(생략, protected, public)
		  
		  3) 예외 처리는 같거나 좁은 방향으로 // 추후 설명
		  
	
	  오버라이딩을 하면 내부적으로 super의 함수가 숨겨지고 재정의한 함수가 사용된다.
	   	   
		ex) 
		class Fahter {
			public void abc() {
					System.out.println("시작")
			}  		
		}
			
			==> 
			class Son extends Father {
			    public void abc() {
					System.out.println("만세")
				}
				
				void xyz() {
					super.abc(); ==> 상위 클래스의 객체가 가지는 함수 호출(시작)
					abc(); ==> 현재 클래스에서 재수정한 함수 호출(만세)
				}
			}	
			상위 클래스의 abc 함수 호출하는 방법 : super.abc();
			하위 클래스의 abc 함수 호출하는 방법 : abc();
			
				
				
		super 
		
		:  자신의 상위 클래스의 객체의 주소를 기억하는 예약된 변수 		
				
			- 사용 목적 : 반드시 소속을 밝혀야 하는 경우가 생길 때 사용한다.		
						  상위 클래스 안에 있는 멤버에 접근하기 위해서 사용
						  
	     +) this : 객체 자신의 주소를 기억하는 변수



	<다형성>
		
		
	Object 클래스 : 자바로 만들어진 모든 클래스들의 최상위 클래스
	   
	 
	 
	  ex) public class Abc {} = Object + alpha
	  	  
	  	  Object o = new Abc(); ==> (o)
	  	  
	  	  상위클래스 변수 = new 하위클래스
	  
	  
	  	
    
		 									   
				
	<instanceof 연산자> : 클래스 new 시켰을 때 만들어진 주소가 어떤 클래스 소속의 주소인지 알아내는 연산자			
	                      연산의 결과는 true 또는 false로 만들어진다.
	  
	  	형식 :     주소    instanceof    클래스이름			
	  	
	  	의미 : 주소가 가리키는 내용이 지정한 클래스 소속인지를 물어보는 것
	    		    (주소가 클래스 이름의 인스턴스인가?)		
	
	    소속이라는 개념은 is a 관계를 따지는 것이다.
	    상속 관계를 따지는 개념이 소속이라는 것이다.
	    			
	    			
	    			

	    			




	    			
	<package와 import>
	
	
		package
		: 자바 프로그램(소스코드)이 들어있는 폴더를 자바에서 부르는 용어 (클래스 이름 충돌 해결)
		  
		 
		  
		 명령 
		   : package   폴더이름;
		   
		  
		  패키지 이름 만드는 권장 사항
		  	: 자신이 사용하는 도메인을 거꾸로 쓴 후 그 다음에 다시 폴더 이름을 붙여서 만든다.
		  	  이 때 경로의 구분자는 /를 쓰는 것이 아니고 자바에서는 .으로 구분해서 처리한다. 		
				
          
          ex) githrd.com
              ==> com.githrd.t0310	
	
				
				
		import
		: 자신이 사용할 클래스가 어느 패키지에 있는 것인지 밝혀주기 위한 명령
				
		   ex) 나  Sample.Test.class		
		   	   친구 abcd.Test.class
		   	   
		   	   ==> 친구의 프로그램을 쓰고 싶다 = import abcd.Test;
           		   내 프로그램을 쓰고 싶다. = import Sample.Test;
           		
           	
           	형식
           		1) import 패키지경로.클래스이름;
           		   ==> 지정한 패키지의 지정한 클래스를 사용할 예정임을 밝히는 것
           		
           		2) import 패키지경로.*;
           		   ==> 지정한 경로에 있는 모든 클래스 중 일부를 사용할 예정임을 밝히는 것
           	
           		
           		2)보다는 1)을 우선 적용
           		
           		   ex) Sample.Test.java
           		   	   test.Test.java
           		   	   
           		   	   import test.Test; 
           		   	   import sample.*;
           		   	   
           		   	   ==> test 패키지의 Test 클래스를 사용함
           		   	   
           		   	   
           	주의점
           		
           		t1 ------- s1
           			  |
           			  |--- s2------- Test1.java
           			  |         |--- Test2.java
   					  |         |--- Test3.java
  					  |
					  |  
           			  |--- Test01.java
           		      |--- Test02.java
           		      | 	   		   	   
				
					import t1.*; => Test01, Test02만 사용할 준비를 함
					
					Test1을 사용하려면 import t1.s2.*;라고 별도로 임포트해야함
					
					* 기호를 사용한 import 명령은 하위의 패키지 내의 클래스까지 사용할 준비를 하는 것이 아니고
					직속 클래스만 사용할 준비를 하는 것
				
			
			
			import 하지 않아도 명시적으로 사용할 수 있는 패키지는 java.lang 패키지(JVM이 기본적으로 찾아봄)
				ex) math, print, String
			
			
			
			static import
			 : static 멤버는 원칙적으로    클래스이름.멤버이름   로 사용한다.
			  이 때 static 멤버 앞에 사용하는 클래스이름조차도 생략할 수 있는데 이처럼 static 멤버를 사용할 때 클래스 이름 생략 가능하도록
			  하는 방법이 static import
			   
			  Math.PI
			  Math.random()
			  
				형식 : import static 패키지경로.클래스이름.*;		  
					 
					 random() ==> Math 클래스의 random() 함수를 호출하게 된다.   	
				
				
				
				
	final 속성
	
	 	1) 변수 : 값 수정 불가 
	 	
	 	2) 함수 : 오버라이드 불가
	 	
	 	3) 클래스 : 상속 불가 			
	
	
	
	
	******
	상위 클래스의 타입 변수로 하위 클래스의 인스턴스를 기억하는 경우
	변수는 레퍼런스(변수) 쪽(처음 값)을 따르고 
	함수는 인스턴스(메모리에 올라간 클래스) 쪽(마지막 값, 오버라이드한 값)을 따른다. (Test05)
	단, 레퍼런스 쪽에 실행하려는 함수가 존재해야 한다.
		
   	     	     
   	     	     
   	     	     
   	     	     

   	     	     
   	     	 










===========================================================================================================================================
##day12

<객체지향언어의 특징>

	1. 상속 : 하위 클래스에서 상위 클래스의 기능을 수정

	2. 다형성 : 상위 클래스의 변수로 하위 클래스의 인스턴스 이용
	
	3. 은닉화 / 캡슐




<Casting> = 주소의 형변환 (상속 관계에서만 가능)

	종류
		1. 자동 형변환 : 하위 클래스 주소가 상위 클래스 변수에 기억
		
					Father f = new Son();
		
		2. 강제 형변환 : 상위 클래스 주소가 하위 클래스 변수에 기억
			
					Father f1 = new Father();
					Son s = (Son) new f1();




<추상 클래스> = 추상 함수 0개 이상 가진 클래스

	형식 :   접근지정자    abstract   class   클래스이름   {}
	
	목적 : 다형성 구현
	
	방법 : 추상 클래스 자체는 new 시킬 수 없음
		
		1. 하위 클래스에서 블록 생성 -> 하위 클래스 new -> 추상 클래스 변수에 담아 사용
		
		2. 추상 클래스 안에 속성이 static이면서 반환값이 자신인 함수 호출
		
			ex) Calendar 클래스
					Calendar cal = Calendar.getInstance();




<추상 함수> = 블록이 없는 함수
	
	형식 :   접근지정자    abstract    반환값타입    함수이름(매개변수);
			
			ex)   public   abstract   void    abc(int a);
			
						


<인터페이스> = 특수한 클래스

	특징 
		
		1. 최상위 클래스 없음
		
		2. 추상 함수만 존재
		
		3. 다중 상속 가능
		
		4. public static final 변수만 존재
		
	목적 : 함수의 기능을 개발자가 정하기 위해서
	
	방법 : 인터페이스에 직접 new 시키는 건 불가능
	
		1. 일반 클래스에 상속 -> 인터페이스 함수 모두 오버라이딩 -> 하위 클래스에 new
			
			형식 : class   클래스이름   (extends  상속해줄클래스)   implements   인터페이스이름
			   
			
		2. static, 해당 인터페이스타입인 함수 다른 클래스에서 호출
		
		

<내부 클래스> = 클래스 안에 다시 만든 클래스
	
	목적 : 클래스 내용이 너무 짧은 경우
	
	종류 
		1. Top Level 내부 클래스 
		
	*	2. 전역 내부 클래스 : 일반 클래스로 만든 내부 클래스
			
			형식 :   class   클래스이름   {}
			
			특징 
				
				1) 바깥 클래스 멤버 사용 가능
				
				2) 바깥 클래스 new 시킨 후 내부 클래스 생성, 다시 내부 클래스 new
				 
				3) 바깥 클래스는 내부 클래스 멤버 사용 불가
				
				
		3. 지역 내부 클래스
		
		
	*	4. 무명 내부 클래스 : 이름 없는 내부 클래스 
	
			사용 방법 : 클래스 new 시키는 순간 오버라이딩해서 사용
			
			형식 :   new   인터페이스/추상클래스이름() {
							추상 함수 오버라이딩
					}



=======================================================================================================================
#day13

<오버라이딩 규칙>

1. 함수 원형 유지

2. 접근지정자 같거나 넓게

3. 예외 처리 같거나 좁게




<예외 처리> : 예외(데이터나 장비에 의한 실행 에러) 발생 시 대처하는 프로그램

	
	1. 형식
	
		try {       
					==> 예외 발생 코드 있는 장소		
		} catch() {
					==> 예외 발생 시 문제점 해결 장소
		} finally {
					==> 예외 관계 없이 반드시 실행
		}
		
	
	2. 원리 : 예외에 대한 정보를 객체로 만들어 catch블록에 그 주소를 전달
	
	
	3. 다중 catch 블록 : try{} 안에는 다양한 예외 발생 요소 존재, 이를 구분할 때 사용
						 좁은 범위의 catch부터 기술
	
	
	4. 예외 정보 출력 
	
		1) 예외 정보 클래스 변수 출력 : 원인 파악
		
			ex) System.out.println(예외정보클래스변수);
			
		2) 예외클래스변수.printStackTrace() 이용 : 예외 정보 + 위치 + 경로 파악
		
	
	5. 목적 : 프로그램 정상 종료
	
	
	
	
	
	<예외 전이> : 함수 내가 아니라 함수 호출한 곳에서 예외 처리하는 것
		
		1. 형식 :  접근지정자   (속성)   반환값타입   함수이름(매개변수)   throws  예외클래스{}
		
		2. 의미 : 지정한 예외 발생 시 함수 실행 중지

    
    
    <강제 예외 던지기> : JVM과 별개로 인위적으로 예외로 인정해야 하는 경우
     	
     	1. 형식 :   throw  new  예외클래스이름();
     	
     
     
    <사용자 예외 클래스> :  예외 발생 원인 알려주는 클래스
    
    	1. 방법
    	
    		1) Exception 클래스를 상속 받은 클래스를 만든 뒤
    		
    		2) toString() 오버라이딩해서 예외의 원인 출력	
    		
    		
 
 ==================================================================================================================================
 
	##day14
	
	
	<오버라이딩 규칙>
	
		1. 함수 원형 유지 (반환값, 이름, 매개변수)
	
		2. 접근지정자 같거나 넓게
	
		3. 예외 처리 같거나 좁게
	
	
	
	<기본형과 참조형>
	
		1. 기본형 타입 : 데이터 비교
			
			ex) int a = 10;  
				int b = 10; 
				a == b (o)
			
		2. 참조형 타입 : 주소 비교
			
			ex) Nemo n1 = new Nemo(10, 20);
				Nemo n2 = new Nemo(10, 20);
				n1 == n2 (x)
				
				
				
	<클래스 사용법>
	
		1. 클래스이름 변수 = new 클래스이름();    (객체로 만들어 Heap에 올림)
		
		2. 변수.abc();						       (변수 이용해 내부 멤버 사용)
				
				
				
				

	<Object 클래스> : 자바의 최상위 클래스
	
		소속 함수
		
			1. equals() : 주소 비교      <---->    String 클래스의 equals() : 내용 비교
			
			2. toString() : 주소(해쉬코드 값) 출력   (데이터 내용이 출력되는 것이 아니다!)
			
			3. protected clone() : 자기 자신을 깊은 복사
			
			4. hashCode() : 해쉬테이블에 코드값 전달
	
	
			
			
	<유용한 클래스>
	
		
		1. String : 간단한 문자열 관리
			
			- 내용 변경 시 새로 저장하고 새로 주소 부여
			
			- new 불필요 
			
				ex) String str = new String("홍길동");
					String name = "홍길동";
					
			- 결합 연산자 사용 가능
			
			- 함수는 데이터 자체를 변경하는 것이 아니라 연산 결과를 반환해주는 것
			
					
		
		
		2. StringBuffer	: 복잡한 문자열 관리
		
			- 내용 변경 시 기존 것에 덮어 씌움
			
			1) 사용법 
				
				- 객체 생성
					
					: StringBuffer buff = new StringBuffer("문자열"//너무 길면 생략도 가능);
				
				- 객체에 문자열 결합
				
					: buff.append("문자열"); 
				
				- 문자열로 변환
					
					: String str = buff.toString();	
					
					
		
		
		3. StringTokenizer : 특정 구분자 기준으로 문자열 자름
		
			* 주의  :  분리된 결과물은 배열과 같은 형태로 버퍼메모리에 기억되고 1회 사용 후 소멸
			
			1) 사용법
			
				StringTokenizer token = new StringTokenizer("문자열", 구분문자);
				
				while(token.hasMoreElement()) {
				
				//하나씩 꺼내서 작업, 더 이상 꺼낼 게 없을 때까지
				Object o = token.nextElement();
				String str = token.nextToken();
			    
			    }
				
				
				
				
				
		4. Math 클래스 : 수학적 기능 처리하는 static 함수로 구성
				
			- new 불필요
				
		
		
		
		5. 래퍼 클래스	: 기본 데이터 타입을 객체로 만듦(다형성 구현)
		
			+) 기본 데이터 타입
				
				- 객체 x
				- 멤버 x
				- Object 타입 자동형변환 x
				
				
						
			* 암기
						
				Stack	   <Boxxing>      Heap
					   ----------------> 
					      <UnBoxxing> 
		      <기본형> <---------------- <참조형>	
				boolean		<------->	Boolean
				char		<-------> 	Character
				byte		<-------> 	Byte
				short		<------->	Short
				int		    <------->	Integer	
				long		<------->	Long
				float		<------->	Float
				double		<------->	Double
						
				
				
				
				
		
		
	<java.util 패키지 소속 유용한 클래스>
	
		1. Objects  :  static 함수로만 구성된 클래스 (new x)
		
			ex) isNull(Object obj) : 인스턴스 유무 확인
			
				+) null : 변수가 기억할 인스턴스조차 없는 상태
	

===============================================================================================================================================================
##day 15


<Math 클래스> 
1. final class : 상속 불가
2. private Math() : new 불가



<null> : 참조형 변수 선언만 한 상태, Heap에 인스턴스는 없음



<java.util 패키지 소속 유용한 클래스>

1. Objects 클래스 : static 함수로만 구성 ( = new 노필요)
	
	ex) isNull(Object obj) : 인스턴스 유무 확인

	+) null : Heap에 인스턴스조차 만들어지지 않은 상태


2. Random : 난수 발생
	
	1) 장점 : Math.random()보다 다양한 난수 발생

	2) 사용법 : seed(난수표의 위치)를 지정해 난수 테이블에서 난수를 꺼낸다.


3. BigDecimal : 정수로 표현할 수 없는 숫자(long 타입보다 큰 숫자) 사용

	ex) 오라클의 NUMBER 타입 숫자를 자바로 표현할 때

	    BigDecimal big = new BigDecimal (“1232342432545436366”);







<정규식 검사> : 	문자열 형식이 규칙에 맞는지 검사

1. 사용 클래스
	
  1) java.util.regex.Patterun = 검사에 쓸 정규식 문법 지정
  2) java.util.regex.Matcher = 실제 검사 실행

2. 정규표현식 문법 

  - 문자 직접 기록 : 해당 위치에 기록한 문자가 와야 한다.
  - [] 안에 기록 : 해당 범위 중 하나 지칭
  - * : 바로 앞에서 지정한 글자가 0개 이상 올 수 있다.
  - . : 모든 문자
  - \ : 해당 문자가 반드시 와야 한다.
  - d : 숫자

  1) c[a-z]* => c로 시작, 알파벳 소문자 0개 이상
							    
  2) c[a-z] => c로 시작, 알파벳 소문자 중 하나
 
  3) c[a-zA-Z]  => c로 시작, 알파벳 대소문자 중 하나				
				
  4) c[a-zA-Z0-9]  => c로 시작, 알파벳 대소문자와 숫자 중 하나
				
  5) .* => 모든 문자 중 0개 이상			
 
  6) C. => C로 시작, 모든 문자 중 하나

  7) C.* => C로 시작, 모든 문자 중 0개 이상			

  8) C\. => C로 시작, 뒤에 .이 반드시
 
  9) c\d => c로 시작, 뒤에 숫자가 반드시

  10) c.*t => c로 시작 t로 끝, 중간에 모든 문자 0개 이상
 
  11) [b|c].* => b 또는 c로 시작, 모든 문자 0개 이상

  12) [^b|c] => b 또는 c 이외의 문자 한 개

  13) .*a.* => a 앞에 모든 문자 중 0개 이상, a 뒤에 모든 문자 중 0개 이상
   14) .*a.+ =>	a 앞에 모든 문자 중 0개 이상, a 뒤에 모든 문자 중 1개 이상

   15) [b|c].{2} => b 또는 c로 시작, 뒤에 모든 문자 중 2개

   16) .{2,3} =>  모든 문자 중 2글자 이상 3글자 이하




<컬렉션> : 많은 데이터 보관 가능한 인터페이스 (클래스의 집합)

	- 크기 자동 증가 (현재 공간 * 2)
	- List 계열과 Set 계열의 상위 클래스는 동일, 서로 변환 가능


종류 
   
1. List 인터페이스 : 입력 순서 보장 o, 중복 데이터 o

  1) Vector : 배열 형태로 데이터 보관하는 컬렉션
   
     * 생성 방법

	- Vector() : 최초 배열 크기 10, 이후는 2배씩 증가
 	- Vector(Collection c) : 다른 컬렉션 데이터 복사
	- Vector(int initialCapacity) : 배열 크기 직접 지정
	- Vector(int initialCapacity, int capacityIncrement) : 배열 크기/추가 크기 지정

     * 주요 함수 : 기능은 같고 매개변수만 다름
	
	- 데이터 입력 함수

	  add(Object obj) : 자바에서 사용하는 모든 데이터 입력 가능한 함수
	  add(int index, Object element)				  
	  addAll(Collection c) : 다른 컬렉션에 있는 데이터 모두 입력 가능			　addAll(int index, Collection c)
	 　addElement(Object obj)				  	
	　insertElementAt(Object obj, int index)		


	- 데이터 수정 함수 : 해당 위치 데이터를 다른 데이터로 교체
				
   	  set(int index, Objcet element)
	  setElementAt(Object obj, int index)
					  
					  		
	- 데이터 꺼내는 함수		   
					
	  get(int index)
	  elementAt(int index)
         firstElement() : 첫번째 요소가 뭔가?
         lastElement()
         elements()		  
	 				  
					  


   2) ArrayList : Vector의 신버전 컬렉션
	
	* 생성 방법 : Vector와 유사

 

   3) LinkedList : 이중 연결 리스트 방식으로 데이터 보관하는 컬렉션
	
	* 특징
	- 데이터 누적 느림	
	- 데이터 삭제, 추가 빠름


   4) 컬렉션 이용 시 참고할 클래스

      * Iterator : 다양한 데이터를 한 가지 방법으로 꺼내기 위해서만 사용하는 클래스
		  
		- List, Set 계열을 Iterator로 변환시켜 사용
 		- 순차적으로 꺼낸 뒤 즉시 삭제

      * Collections : 컬렉션 이용 시 필요한 부가 기능 제공하는 클래스 
		
		- 매개변수 :　Collection -> List or Set
			         List    ->   List
				 Set    ->   Set
				 Map   ->   Map
		
		- sort() = 오름차순
		  sort(List list, Comparator c) = 내림차순
  




   2. Set 인터페이스 : 입력 순서 보장 x (규칙 따로), 중복 데이터 x  
		   =>  꺼내는 함수가 없다.
			1) Iterator로 변환
			2) List 계열로 변환
	
     * 종류

	1) HashSet : HashCode로 정렬해서 보관하는 컬렉션

	2) TreeSet : Tree Sort 알고리즘으로 오름차순 보관하는 컬렉션
	
	  생성 방법
	     - TreeSet(Comparator comparator) : 정렬 방식 변경해서 생성
	     - TreeSet(SortedSet<E> s) : TreeSet으로 다시 TreeSet 생성
    
      * 참고 함수
	
	1) subSet() : 특정 부분만 골라서 새로운 Set 생성
   	2) headSet(E toElement) : 처음부터 지정한 부분까지 골라서
 	3) tailSet(E fromElement) : 지정한 부분에서 마지막까지 골라서


   3. Map 인터페이스 : 입력 순서 보장 x, 중복 데이터 o (키값은 중복 불가)			  
            		               	  
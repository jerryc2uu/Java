# day06

 1. for 명령

    선조건 처리 명령이다.
    for(;;) 처럼 안의 내용을 기술하지 않아도 무방하다.
    이 때 조건식은 항상 true로 처리가 된다. (안 쓰면 true)
    
    
 2. while 명령

 	-선조건 처리 명령
 	-for 명령과는 구분되게 형식 내부에 카운터 변수 선언 부분이 없다.
 	-따라서 카운터 변수로 실행 횟수를 제어하고자 한다면 
 	 반드시 명령이 시작되기 전에 카운터 변수를 선언 및 초기화를 해주고
 	 명령(블럭/{}) 내부에서 증감식으로 증감해서 횟수를 제어해야 한다. (카운터 변수가 없기 때문)
 	
 
 3. do while 명령   
 	
 	-후조건 처리 명령
 	-조건식이 fault(악조건 하에서도)이어도 적어도 한 번은 실행 내용을 실행하는 반복문.
 	
 	
    참고 ]
    
    	지역변수 : 해당 블럭 내에서만 사용할 수 있는 변수 (블럭이 끝나면 해당 변수는 사라진다.)
    	          
    	          ex) 카운터 변수
    	          
    	전역변수 : class 내의 어디서든지 사용할 수 있는 변수
    	
    	           (class 블럭 바로 아래 기본 데이터 타입으로 변수를 만드는 경우 자동으로 초기화 된다.
    	           그 외에는 null. 
       	           static은 먼저 메모리의 static 영역에 올려놓는 것
    	           그 외에는 클래스가 메모리에 올라갈 때 같이 올라감)
    	
 ------------------------------------------------------------------------------------------------------------------------
 flag 기법
  : 프로그램을 실행하다 보면 두 가지 이상의 경우가 발생되는 순간이 존재한다.
  	그 후에 어떤 경우가 발생했는지를 알아보는 방법
  	
  	예 ]
  	
  	  for(;;) {
  	  	실행내용1 (반복할 때마다 실행될 것, 조건과 무관)
  	     
  	     if (조건) {
  	         break;
  	         }
  	         
  	         실행내용2
  	      }      	
         (1)
         
         실행내용1의 경우는 반복문의 마지막 회차까지 실행됐는지 여부는 판별하기 어렵다.
         실행내용2의 경우도 마찬가지. 
         ==> 1번 부분은 for 명령이 종료되면 실행되는 부분
 		 
 		 이 때 
 		 (1) 부분을 실행할 때 
 		 위의 반복문이 정상적으로 모두 반복을 해서 실행되었는지
 		 아니면 중간에 break; 명령으로 종료가 되었는지를 
 		 판별해내는 기법
 		 
 		 방법 ]
 		    시작하기 전에 변수에 특정 데이터를 기억시켜놓고 
 		    특정 순간이 발생하면 변수의 데이터를 변경시킨다.
 		    
 		    (1) 부분을 실행할 때 그 변수의 데이터를 살펴보면 
 		    위의 반복문이 정상적으로 모두 처리되었는지 
 		    중간에 강제 종료 되었는지 확인할 수 있게 된다.
 		    
========================================================================================================================

 <레이블이 붙은 반복문>

	사용 방법 ]
		레이블이름:
		for(;;) {
		  for(;;) {
		  	  실행내용
		  		if() {
		  			break or continue  레이블 이름 ;
		  		}
		    }
		} 		    
 		    
 ex ] 
   2 x 1 = 2
   ....
   2 x 9 = 18
   
   ....
   5 x 1 = 5
   5 x 2 = 10
   5 x 3 = 15 (x)
   
   6 x 1 = 6
   ....
   
   9 x 9 = 81
   
 주의사항 ]
 	 레이블을 사용한 제어는 반드시 소속 반복문 한해서만 적용된다.
 	 감싸고 있는 반복문에 한해서만 적용가능하다.
     레이블은 반드시 소속 반복문에서 붙일 것
           (반복문에서만 break, continue 사용, 그리고 switch문의 case에서만 break 쓴다.) 	 
 	 예 ]
 	  
 	   for(;;) {
 	    	loop:
 	    	for(;;) {
 	    		for(;;) {
 	    			if() {
 	    				break loop; (ㅇ)
 	    			}
 	    		}
 	    	}
 	  		
 	  		for(;;) {
 	    		for(;;) {
 	    			if() {
 	    				break loop; (x)
 	    			}
 	    		}
 	    	}
 	   }  		 
-----------------------------------------------------------------------------------------------------------------------

<continue 명령>
    
    반복문에만 사용되는 명령 (break는 switch에)
    현재 반복을 중지하고 다음 반복을 처리하도록 하는 것	
    
    ==> 즉 현재 작업을 중지시키고 현재 작업은 무의미하므로 더이상 진행하지 말고
     	다음 반복 작업을 진행하도록 하는 것

   주의사항 ]
        반복 명령문에 따라서 실행 위치가 달라진다.
        
        for(카운터 변수 선언 및 초기화; 조건식; 증감식) {
    		if(조건식){
    			continue;
    		}
        }    
     	 
     	 ==> 이처럼 for 반복문의 경우는 continue 명령을 만나면 증감식으로 실행을 진행한다.
     	 
     	 while(조건식) {
     	 	if() {
     	 		continue;
     	 	}
     	 }
     	   
 	    ==> 위의 경우처럼 while 반복문의 경우는 continue 명령을 만나면 반복문의 조건식을 실행한다. 
 	        이 경우 조건식으로 진행하여 조건식의 결과값이 참이면 다시 반복한다.
 	        
 	    do {
            (1)
            continue;
            (2)
 	    } while(조건식(3));    
 	    (4)
             	    
 		
 		(1) -> continue -> (3) 참  -----> (1) 
 							   거짓 ----> (4) 
 							   
 * continue 명령 역시 감싸는 반복문에 레이블을 붙여서 제어할 수 있다.
 							   
 							   
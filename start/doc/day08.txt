#  day08

배열의 복사

	 종류  ]
	 
	 1. 얕은 복사
	    ==> 주소만 복사하는 방법
	    
	    if문의 블럭이 닫히는 순간 주소도 잊혀짐. 다시 쓰기 위해 블럭 밖에 있는 배열 변수에다 이 주소를 기억시킴.
	    이 때 쓰는 게 얕은 복사.
	    
	    
	    특징 ]
	    
	       데이터는 공유하기 때문에 한 곳에서 수정하면 다른 곳에서도 수정된 내용을 사용
	       (heap에 만들어진 같은 주소를 사용하기 때문에)
	       
	    방법 ]
	      
	      1) int[] a = new int[5]; ==> 스택에 변수 만들어지고, heap에서 주소까지 할당된 상태
	      
	         ....
	     
	         int[] b; ==> 스택에 변수만 만들어 놓은 상태, 주소는 아직 할당되기 전
	         
	                ==> 이 변수는 배열의 주소를 기억할 변수를 stack에 만들어준 결과..
 	                    b 안에는 데이터는 기억할 수 없고(배열을 만들어주지 않았으니까) 오직 같은 Heap 타입의 int[] 의 주소만 기억할 수 있다.
 	                    데이터를 추가하거나 꺼내오는 작업은 할 수 없다.
 	                    오직 int[] 의 주소만 대입시킬 수 있는 상태.
	        
	        
	      2) b = a; => 얕은 복사가 된다. a에서 만든 배열을 같이 공유하게 된다.
	      
	           참고 ]
	      
	            얕은 복사는 언제 사용되는가?
	            지역변수(블럭 안에서만 쓸 수 있는 변수)는 그 지역에서만 사용할 수 있으므로 
	            다른 지역에서 heap 영역의 데이터를 사용할 목적으로 많이 사용되는 방법 
	            (heap에 있는 것들은 프로그램이 종료될 때까지 계속 유지, 메모리가 모자라지 않는다면)
	      
	  2. 깊은 복사
	  
	     ==> 주소가 아니라 데이터를 통째로 복사하는 방법 (주소 자체가 새롭게 만들어 지는 것)
	     
	         데이터가 복사되었다는 것은 heap 영역에 다른 인스턴스(new 명령으로 생겨난 결과물)가 만들어졌다는 것이므로
	         변수가 기억하는 데이터의 주소가 달라지게 된다. 
	         따라서 복사된 데이터는 독립적으로 사용된다!
	        
	      방법 ]
	      	
	      	명령을 사용해서 처리하면 된다. 하나씩 꺼내 추가하려면 반복문을 사용해야 하기에 번거롭다.
	      	그래서 자바에서는 새로운 명령을 따로 만들어 놨다. 
	      	
	      	 System.arraycopy(#1, #2 ,#3 ,#4, #5); : 시스템 클래스가 가지고 있는 arraycopy라는 함수가 있다.
	      	
	      		#1 - 원본 배열의 주소
	      		#2 - 원본 배열의 복사를 시작할 위치
	      		#3 - 복사받을 배열의 주소(주소는 변수가 기억하고 있다.)
	      		#4 - 복사받을 배열의 시작위치 값 (어디 인덱스에서부터 채워나갈 것인지 정해주는 것)
	      		#5 - 복사받을 데이터의 갯수 
	      		
//데이터가 바뀌지 않으려면 깊은 복사를 해야 한다.
	      		
-----------------------------------------------------------------------------------------------------------------------------------------

배열의 단점
 
     1. 한 번 배열의 크기를 정하면 크기 조절이 불가능하다. 다시 배열을 만들어 줘야 함.
     	
     	예 ]
     		int[] no1 = new int[10];
     		...
     		// 작업을 하다가 10개를 추가해야 하는 경우
     		int[] no2 = new int[20];	      		
     		
     		// 데이터 복사
     		System.arrycopy(no1, 0, no2, 0, 10);
     		// 이후 10개의 추가 데이터 입력
     		no2[10] = ???;
     		no2[11] = ???;
     		....
     		
     2. 같은 형태의 데이터만 관리할 수 있다. (타입을 정한다는 건 그 데이터만 입력해야 한다는 의미)
     
        ==> 주소는 Heap 타입에 의해서 결정되고 Heap 타입이 다르면 사용할 수 없다.
	 	 	
	 	 	예 ] 
	 	 	
	 	 		int[] a = new int[10];
	 	 		
	 	 		float[] b;
	 	 		
	 	 		b = a; (x)   heap 타입이 서로 다르기 때문에 절대로 불가능
	 
--------------------------------------------------------------------------------------------------------------------------------------------

String 배열

  	참고 ]
  		String 역시 참조형 타입(기본형 아님)
  		
  		String str = "Hong"; (리터럴 풀의 주소를 바로 기억)
  		
  		str에는 데이터 자체의 주소가 기억이 되고 
  		
  		String str = new String("Hong");
  		라고 변수를 만들면 변수는 Heap에 만들어진 인스턴스의 주소를 기억하고
  		인스턴스가 데이터의 주소를 기억한다.
  		
 ------------------------------------------------------------------------------------------------------------------------------------------
 String 배열 만들기
 
  	String[] str; // 배열 변수 선언(스택에 변수를 준비, 데이터 기억되기 전)
  	str = new String[5]; 
      ==> 기본 데이터 타입은 자동으로 데이터가 채워져 있었으나, 이 경우 데이터가 초기화 안 된 상태
  		  아직 각 인덱스가 비어있는 상태 (데이터가 결정이 안 된 상태)
  	
  	str[0] = "Hong";
  	str[1] = "Dooly";
  	 ==> 위처럼 데이터 공간까지 따로 만들어줘야 한다.
  	 
  	String 배열도 초기화가 가능하다.
  	
  	String[] names = {"둘리", "제니", "리사", "로제", "지수"};
  	
 ---------------------------------------------------------------------------------------------------------------------------------------------
 참고 ]
 	문자열도 필요에 따라서 char[] 형태로 변환해서 사용할 수 있다.
 	
 	방법 ]
 		toCharArray();
 		
 		예 ]
 		 String name = "jenny";
 		 
 		 char[] ch = name.toCharArray(); 	  	  
    	 
    	 ch[0] = j
    	 ch[1] = e
    	 ch[2] = n
 -------------------------------------------------------------------------------
 
 참고 ]
    String 클래스에서 자주 사용되는 함수
    
    	1. charAt(위치값) : 해당 위치의 문자를 알려준다.
    	2. length() : 문자열의 길이를 알려준다.
    	3. substring() : 문자열 중에서 원하는 문자열만 따로 뽑아서 반환(문자열 일부만 잘라서 반환, 일부만 꺼내줌)
    			
    			형식 1 ]
    			   substring(시작위치);
    			   ==> 시작위치에서부터 맨 마지막까지 모두 추출
    			형식 2 ]
    			   substring(시작위치, 종료위치);   
   	 				==> 시작위치에서부터 종료 위치 이전 문자까지 추출해준다. 
   	 					종료 위치 문자는 포함 아님.
   	 				
   	 				** 주의 ]
   	 				    시작위치는 0부터 카운트해서 지정한다. (인덱스 쓰겠다는 뜻)
   	 				    종료위치는 1부터 카운트해서 지정한다.
   	 					
      	4. equals() : 문자열의 데이터 자체가 같은지 비교해서 논리값으로 반환해주는 함수 (데이터 자체를 비교)
 
 ---------------------------------------------------------------------------------------------
 
  2차원 배열
  	==> 1차원 배열을 관리하는 배열
  		==> 배열 안에 다시 배열이 들어있는 형태 
  			(정확히는 배열 안에 1차원 배열의 주소가 기억된다.)
  		
  	2차원 배열을 만드는 방법
  	
  		1.  배열 주소를 기억할 변수를 만든다.
  		   ==> Heap 영역에 있는 데이터는 주소를 알아야 사용하기 때문이다.
  		   
  		   방법 ]
  		   		데이터타입[][] 변수이름;
  		   		==> [] 1개이면 1차원 배열
  		   		    [] 2개이면 2차원 배열 
  		   		    [] 3개이면 3차원 배열
  		   		    ...
  		   예 ] 
  		   		int[][] num;
  		   		
  		   		num = new int[5]; (x) : Heap 타입이 달라서 안 된다.
  		   		
  		 2. 1차원 배열 몇 개를 관리할지를 결정하고
  		 	1차원 배열의 주소를 기억할 메모리를 만든다.
  			
  	  	  	방법 ]
  	  	  		new 데이터타입[갯수][]; 
  	  	  		==> 갯수는 1차원 배열의 갯수를 지정한다.
  	  	  		
  	  	  	예 ]
  	  	  		num = new int[5][];
  	  	  		
  	  	 3. 실제 정수를 관리하는 1차원 배열의 길이를 결정하고 
  	  	 	1차원 배열의 주소를 기억할 메모리를 만든다.
  	  	 	
  	  	 	방법 ] 
  	  	 		new 데이터타입[갯수];    	
      		예 ]
      			num[0] = new int[3];
----------------------------------------------------------------------------------------------------------------------------------------

	참고 ]
		2차원 배열도 사각형 형태의 배열을 만들 수 있다.
		
		형식 ]
			데이터타입 [][] 변수 = new 데이터타입[행수][열수];
			
		예 ]
			int[][] num = new int[5][3];
			
			==> 정수 3개를 관리하는 배열 5개를 관리하는 배열

		주의 ]
		   이해를 돕기 위해서 사각형으로 설명하지만 실제로는 별도의 메모리 공간을 차지하는 배열이 만들어지고
		   그 배열들을 관리하는 배열이 다시 만들어진다.
		   
     참고 ]
         2차원 배열도 초기화가 가능하다.
         
         	방법 ]
         		
         		int[] num = {데이터1, 데이터2, ....}; // 데이터 갯수 만큼 만들어지고 입력된 데이터로 초기화가 된다. 
         		
         		int[3][2 or 3 or 4...] num = {{1, 2}, {3, 4, 5}, {6, 7, 8, 9}};
         		 
         		참고 ]
                   여기서도 배열의 갯수를 지정할 수는 없다.      
         	
						
  		
----------------------------------------------------------------------------------------------------------------------------------------  		

   		
  	int[] no = new int[10];
  	
  	no = new int[] {1,2,3};
 	
  	
  	
  		

	 		      
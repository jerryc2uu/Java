day09

기본 문법
함수
객체지향 (클래스, 인터페이스, 추상클래스)
유용한 클래스들
컬렉션 (리스트, 셋, 맵)
쓰레드
입출력
네트워크
---------------------
jdbc
awt, swing - GUI 제작 클래스

=====================================================================================================================================

함수(Method, Function) 함수만 메모리에서 불러올 수 있으면 함수, 다른 것에 소속되어 있는 건 메소드 
                       자바는 클래스에 함수가 들어간다. 클래스를 메모리에 올려놓지 않으면 함수를 쓸 수 없다. 이건 Method.
	
	변수나 함수가 객체로서 따로 구분되는 언어들이 파이썬, 자바 스크립트.
	ex) abc(...){}
		xyz(...){}
		
		abc(data); - 자바
		abc(function(){}, ) - 파이썬, 자바스크립트
		
 1. 함수란? 
 	한 가지 작업을 실행하기 위해 만들어진 가장 작은 단위의 프로그램.
 	즉, 기능의 최소 단위
 	
   1) 프로그램이란?
 	이런 함수들이 모여서 원하는 목적을 이루도록 구성하는 것. (자바에서 클래스가 가질 수 있는 건 변수(데이터 기억)와 함수(데이터 가공))
 	
   2) **참고**
   	- 함수는 누군가 호출해야만 실행된다. 함수 스스로가 실행되는 경우는 없다. 메인함수 역시 JVM이 호출
   	
   	- 함수는 실행이 완료되면 자신을 호출한 곳으로 실행 순서를 넘긴다.
   	   
   	  ex1 ) class Test {
   	   		static void abc(){
   	   			(1)
   	   		}	
   	   		public static void main(String[] args){
   	   			(2)
   	   			abc();
   	   			(3)
   	   		}
   	   		
   	   		static void xyz(){
   	   			(4)
   	   }	
   	   
   	   
   	   ==> (2) - (1) - (3) - 종료  (4)는 호출하지 않은 것		
   	   
   	   ex2 ) class Test {
   	   		static void abc(){
   	   			(1)
   	   			xyz();
   	   			(2)
   	   		}	
   	   		public static void main(String[] args){
   	   			(3)
   	   			abc();
   	   			(4)
   	   		}
   	   		
   	   		static void xyz(){
   	   			(5)
   	   }
   	   
   	   ==> (3) - (1) - (5) - (2) - (4) - 종료
   	   
   	  
 2. 함수 만드는 방법
 	
 	1) 형식
 		접근지정자    [속성]    반환값타입     함수이름(매개변수리스트...) {
 			함수내용
 		}
 		
 	2) 속성
 		- final : 변수에 final이 붙으면 입력한 데이터 수정 불가 = 상수 (snake 표기법으로 대문자로 변수 이름 표기, 변수 선언 시 초기화도 같이 해야 함.)
 		- static : 변수, 함수에 붙음. 스태틱 영역에 미리 올려짐.  스태틱 멤버만 호출할 수 있음.
 		- abstract
 		....
 			
 	3) 접근 지정자 : 해당 개체에 접근할 수 있는 권한을 지정해놓은 것 (//나중에 클래스에서 설명)	
 		
 	4) 함수 이름 : 개발자가 지정하는 사용자 정의어 (식별자 만드는 원칙에 근거해 제작)
 	
 	5) 매개변수 리스트 : 변수 선언 형태로 만드는 것, 갯수와는 상관이 없음 	
 						
 						==> 함수가 원하는 작업을 하기 위해서 반드시 필요한 데이터가 있을 것이다. (두 수를 합해야 한다 -> 두 수는 반드시 필요)
 							이 데이터를 기억할 준비를 하는 것이다. 		
 	
 	6) 반환값 타입 : 함수는 한 가지 목성을 달성하기 위한 가장 작은 단위의 프로그램
 					 함수를 실행한다는 말은 그 목적을 달성하겠다는 의미
 					 이 때 그 달성된 목적에 따라서 결과가 나오거나 안 나올 수 있다. 
 					 ex) println - 콘솔 화면 출력 vs math.random - 난수 발생
 					 
 					 반환값 타입이란 함수가 어떤 작업을 실행한 결과를 알려주는 것
 					 이 결과는 경우에 따라서 달라진다.
 					 - 결과가 존재하는 경우 : 그 결과에 대한 타입만 적어줌  ex) plus 함수 -> int  	
 					 - 결과가 존재하지 않는 경우 : 반드시 반환값 타입에 "void"(비어있다는 뜻)라고 적어줌 ex) println
 	
 	   - 참고 : 함수는 한 가지 목적을 위해 만들어지는 가장 작은 단위의 프로그램
 	   			따라서 반환값은 ***** 한 개 or 없다 ***** 				  	
 				반환값이 두 개 이상인 함수는 자바에서는 절대로 만들 수 없다.
 				
 				ex) public int, float abc() {
 				}  -----------------> 자바에서는 절대 불가능
 				
 		
 		따라서 함수는 다음의 4가지 형태를 벗어날 수 없다.
 		
 		1. void abc() {} : 반환값 없고 매개변수 없음 
 		2. int abc() {} : 반환값 있고 매개변수 없음
 		3. void abc(int no) {} : 반환값 없고 매개변수 있음
 		4. int abc(int no) {} : 반환값 있고 매개변수 있음

----------------------------------------------------------------------------------------------------------------------------------------
 return 명령 : 함수 안에서 사용할 수 있는 명령  ex) break, countinue과 같은 맥락 (반복문에만 적용되는 명령)
 
  1. 의미 
  	1) 함수 실행을 종료하라
  	2) 결과가 있다면 결과를 내보내고 함수 실행을 종료하라
  	
  2. 형식
  	1) return;
  	2) return 데이터; - 데이터 반환해주고(이 함수를 실행한 위치에 데이터를 내보내주고) 실행 중인 함수를 종료하라
  		
 	<참고>
 		- 반환값이 void(없음)인 경우는 반드시 return;만 사용할 수 있다. return; 생략도 가능
 			-> 함수의 내용이 다 실행되면 블럭이 닫히고 함수가 자동 종료되기 때문
 				
 		- 반환값이 void 아닌 경우(있음)는 반드시 return 데이터;만 사용할 수 있다.
 		
==========================================================================================================================================
  
  함수의 사용 방법 : 함수는 반드시 호출해야만 사용할 수 있다.
  					 따라서 함수를 사용한다는 것은 그 함수를 호출한다는 의미
  					 
  
  1. 형식 : 함수이름(데이터, ...//매개변수 리스트와 갯수 같아야 함); 		
 		
 		- 데이터란? 
 			함수는 그 함수가 실행되기 위해 필요한 데이터를 받을 준비를 하고 있다. = 매개변수
 			따라서 그 함수에 일을 시키기 위해서는 필요한 데이터를 반드시 입력해줘야 한다.
 			결론적으로 데이터(=파라미터, Parameter)란 함수가 준비하고 있는 매개변수 리스트에 기억할 데이터를 제공하는 것
 			데이터는 그 함수가 준비한 매개변수의 갯수, 형태, 순서와 반드시 일치해야 한다.(넘쳐도 모자라도 안 됨)
   					
  			ex) void abc(int a){}
  				--> abc(); (x) 데이터 입력이 안 됐음
  					abc(5); (o) 
  					abc(3.4); (x) 데이터 형태가 다름
  					abc(3, 4); (x) 데이터 갯수가 다름	
 
 -------------------------------------------------------------------------------------------------------------------------------------------
 
 	반환값 사용 방법 : 함수의 실행이 종료되면 반환값을 줄 수 있다.
 					   이 반환값은 함수 호출 부분에 그대로 들어온다.
 					   따라서 함수 호출 부분에 예상되는 반환값을 기록해보고 문법적으로 이상이 없으면 그것이 반환값의 사용이 된다.
 					   
 					   ex) int abc(){
 					   		int k = 5;
 					   		return k;
 					       }	
 		
 						   void xyz(int a){}	
 							
 						   int lmn(int a){
 						      ...
 						      return ??;
 						   }
 						   
 						   abc(); --> (o)
 						   int a = abc(); --> (o)
 						   System.out.println(abc()); --> (o)
 						   xyz(abc()); = xyz(5);와 동일 --> (o)
 						   abc(lmn()); --> (x) 이런 함수는 만들어놓지 않았기 때문
 		
 		
					   참고 : 반환값이 있는 함수라도 필요하지 않으면 반환값을 이용하지 않아도 상관 없다.	 								
 		
 ================================================================================================================================================
 
  객체지향언어(Object Oriented Programming = OOP)	
   : 클래스를 이용해서 프로그램을 만들어 나가는 언어
   
  클래스
   : 하나의 목적을 달성하기 위해서 필요한 기능들을 모아 놓은 프로그램의 기본 단위 (클래스를 제일 먼저 만든다)
   
    EX) 문자열 관리 -> String (기본 데이터 타입x 클래스 타입)
        네트워크 처리 -> Soket
       
	클래스의 구성 요소
	   1) 변수(Field) : 필요한 데이터를 보관하고 있어야 한다.
	   2) 함수(Method) : 뭔가(필요성)를 해결하기 위한 기능이 있어야 한다.
       
		=> 이 두 가지를 합쳐서 멤버(Member)라고 부른다. (클래스 바로 아래에는 멤버 제외한 일반명령은 올 수 없다.)      
  		
 	클래스 제작 방법
 		1) 형식 : 접근지정자  [속성](//생략가능)  class	클래스이름 {
 					변수 선언;
 					변수 선언;
 					
 					함수 선언;
 					함수 선언;
 		           }	
 		           
 ********중요한 점 *******
 클래스는 설계도에 불과하다. (붕어빵 틀)
 즉, 클래스만 가지고 있다고 해서 이것이 실행되는 것이 아니다.
 반드시 클래스가 실행 가능한 물건으로 만들어져야(메모리에 올려진 상태) 실행할 수 있다. 
 
  Object(객체) = Reference(변수) + Instance(인스턴스)
  
  결국, 객체지향언어는 클래스를 기반으로 해서 만들어지는, Object에 의해서 만들어지는 프로그램
  이미 만들어져 있는 건 가져다 쓰거나 조금 수정하고, 없는 건 내가 만드는 게 객체지향언어 
  개발자가 전부 코딩하지 않고 부품별로 코딩해서 필요한 순간에만 가져다 조립해서 쓴다. 
  
  
  
  +) 자바는 메모리에 올려진 것들의 주소를 알아야 사용할 수 있다.
  이 역할을 하는 것이 변수
  틀은 같아도 담겨진 내용은 다를 수 있다.
  
  메모리에 올려져 있는 클래스 = 객체

----------------------------------------------------------------------------------------------------------------------------------------------

	객체(Object)를 만드는 방법
	: 객체는 JVM이 만든다. 
	  개발자는 필요한 부품을 만들어 달라고 JVM에게 명령만 내린다.
	   
	 1) 형식 : 클래스이름 변수;
	 			변수 = new 클래스이름();
	 			
	      ex) Test라는 클래스가 있다면?
	          
	          Test t; --> t는 레퍼런스 변수가 된다.
	          			  이 변수의 Heap Type은 Test가 된다.
	          
	          t = new Test(); --> new 명령을 통해 클래스가 Object가 된다. 컴퓨터가 물건을 만든다는 개념은 메모리에 클래스가 만들어진다는 개념과 같다.
	 			 -인스턴스-
	 		  - 객  체 --  
	 		  
	 		  따라서 Heap에 만들어진 클래스를 Instance라고 부르고, 만들어진 Instance의 주소를 기억할 변수를 Reference라고 부른다.
	 		  이 두 개를 통칭해서 Object(객체)라고 한다.      
	          
	          +) 메모리에 올려놓아야 프로그램이 실행 가능해진다. 
	          
	          ex) class Test {
	          		int a;
	          		int b; --> 
	          		void abc(){} --> 독립적으로 호출할 수 없고 Test가 메모리에 올려져야만 사용할 수 있는 함수. 즉, 메소드
	          		void xyz(){}
	               }			
	          	
	          	  ==> 하드에 저장돼 있는 소스코드일 뿐
	          	  
	              객체로 만들기 위해서는
	              
	              Test t;
	              t = new Test();

--------------------------------------------------------------------------------------------------------------------------------------------------

	객체를 사용하는 방법
	: 객체를 사용한다는 개념은 그 목적을 달성하기 위해서 필요한 데이터를 기억하거나, 필요한 함수를 호출(이용)하는 것	
	
	1) 형식 : 주소.변수; or 주소.함수(데이터); // 주소 = 변수 (t), 
	
		ex) Test 클래스의 a 변수에 10을 기억시킨다.
			Test t;
			t = new Test();
			t.a = 10;
			+ 함수 실행?
			t.abc();
			
	+) 함수로딩
	1. 함수 이름이 같아야
	2. 매개변수 순서 형태 개수 달라야
	3. 반환값과 노상관

          *****참고*****
          	클래스 하나당 Object는 여러 개 만들어도 상관없다.
            즉, 설계도는 한 장만 있으면 되는데 설계도 한 장으로 물건은 여러 개 만들 수 있다.
			이 때 주소를 이용해서 사용하게 되므로 
			
			ex)  Test t = new Test();
				 Test t2 = new Test();
				 
				 toPrint()가 멤버 변수 a의 내용을 출력해주는 기능이라고 가정할 경우
				 t.a = 10;
				 t2.a = 1000;
				 
				 t.toPrint(); ==> 10 출력
				 t2.toPrint(); ==> 1000 출력
			
			따라서 각각의 객체는 별개로 독립되어서 실행될 수 있다.

  <참고>
  
 	지역변수 : 해당 지역에서만 사용할 수 있는 변수, 그 코드가 실행되는 순간 변수가 만들어지고 그 블럭을 벗어나면 그 변수는 사라짐
 			   
 	전역변수 : 모든 지역에서 사용할 수 있는 변수, 프로그램이 종료되지 않는 이상 계속 쓸 수 있다.
	            클래스 안에서 만들어진 변수는 new 시키는 순간 Heap 영역에 만들어지기 때문.
	            Heap 영역의 특성에 따라서 계속 사용할 수 있게 된다.	(공간이 아주 크다, 모자라면 다른 곳에서 가져다 쓴다, 알아서 지운다.)
	            
	            인스턴스의 
	            탄생시점 : new 시키는 순간
	            소멸 시점 : 프로그램이 종료되는 순간

=======================================================================================================================================================
	
	객체의 배열
		: 하나의 클래스(붕어빵 틀)를 가지고 여러 개의 객체(붕어빵)를 만들 수 있으므로 
		  이 때 만들어진 객체들을 배열로 만들어서 관리할 수 있다. (변수 여러 개 만들지 않아도 됨)
		
	만드는 방법 
	 	: Test[] t; -> Test 인스턴스들을 배열로 관리할 주소 변수 만든다.
	 	  t = new Test[갯수]; -> 관리할 갯수를 정해서 배열을 만든다.
	 	  
	 	  ****주의****
	 	  아직 실질적인 객체는 만들어놓지 못한 상태.
	 	  
	 	  class Test {
	 	  		int a;
	 	  }
	 	  
	 	  Test[] t = new Test[5]; --> Test 타입의 객체를 관리할 공간만 확보한 상태
	 	  
	 	  t[0].a -->이렇게 접근해서 a 변수에 기억된 숫자를 꺼내오지 못한다. 채워진 데이터가 없는 null 상태
	 	  
	 	  따라서 
	 	  	for(int i = 0 ; i < 5 ; i++) {
	 	  			t[i] = new Test();
	 	  	}	 	  	 
			위 작업으로 실제 오브젝트를 만들어서 채워줘야 한다.
			
	     사용 방법 
	     	: 배열변수[위치값].변수이름 = 데이터이름;	            
	     	: 배열변수[위치값].함수이름();	            
				
			  배열변수[위치값] 안에 있는 주소는 오브젝트 참조 주소이기 때문에 "."을 이용해서 접근해야 한다.
			  즉, 소속을 밝혀줘야 한다.

-------------------------------------------------------------------------------------------------------------------------------------------------

	함수의 오버로딩(OverLoading : 함수의 중첩)
 	: 함수 이름을 중첩해서 만든다는 의미
 	  
 	  원칙적으로는 한 클래스 안에서 함수의 이름은 모두 달라야한다. 
 	  같은 이름의 함수가 존재하면 오류가 발생한다.
 	  이러다보니 가독성에 있어서 문제가 발생	
 	  즉, 가독성이란 함수의 이름만 봐도 그 기능을 알 수 있어야 함을 의미
 	  함수의 이름을 모두 다르게 만들면 가독성이 떨어질 수밖에 없음
 	  이를 해결하기 위해서 도입된 문법이 함수의 오버로딩

	  오버로딩이란 같은 클래스 안에 같은 이름의 함수를 만들 수 있게 해주는 것
	  
	  조건 0. 해당 클래스에 오버로딩 하려는 함수가 있어야 한다. 
	       1. 함수의 이름이 같아야 함 
	  	   2. 매개변수의 갯수, 순서, 형태 중 하나 이상이 달라야 함
	  	   3. 반환값과는 상관없다.
	  	   
	  	   EX) void abc(){}
	  	   	   void abc(int a){}  ==> (o)	  
 	  		   
 	  		   void xyz(int a){}
 	  		   void xyz(float a){} ==> (o)
 	  		   
 	  		   void lmn(int a, float b){}
 	  		   void lmn(float b, int a){} ==> (o)
 	  		   
 	  		   int efg(){}
 	  		   void egf(){} ==> (x) / 반환값과는 상관없기 때문에
 	  		   
 	  		   void hij(int a, int b){} 
 	  		   void hij(int b, int a){} ==> (x) / 입력되는 타입이 동일하므로 같은 형태로 취급
 	  		   
 	  		   결론적으로 함수를 호출할 때 정확한 함수를 선택할 수 있도록 해야 한다.	
 			  	원래 함수의 오버로딩 규칙

     <사용법>
     	다른 사람이 만든 클래스에도 오버로딩이 구현된 함수를 볼 수 있다.
     	이 함수들을 사용하는 방법은 원하는 기능을 하는 함수가 요구하는 데이터를 형태와 순서에 맞춰서 정확하게 입력해주는 것
     	
			  
            		               	  
#day11

	this 
  
     : 현재 실행 중인 객체의 주소를 기억하는 약속된 변수 
 	(JVM이 클래스를 처리하기 위해서 JVM이 사용하는 변수. 개발자는 이 변수를 사용할 일이 거의 없다.)
   
   규칙 1. 모든 멤버는 사용할 때 반드시 앞에 주소가 있어야 한다.
   			(멤버는 클래스 안에 만들어진 변수나 함수를 지칭
   			따라서 new 시킨 후 그 주소를 기억해 놓았다가 그 주소를 이용해서 사용하는 것)
   			
   		2. 주소가 없다면 JVM이 자동적으로 this를 붙여준다.
   		
   		3. 멤버 함수를 호출할 때는 무조건 주소값을 함수에게 알려주도록 약속되어있고
   			함수는 this 변수를 준비한 후 함수를 호출할 때 알려준 주소를 기억하게 된다.
   			
   		# 유일하게 개발자가 this를 사용해야 하는 경우?
   			지역변수와 멤버변수가 이름이 동일하게 만들어질 때, 그 함수는 지역변수를 우선적으로 사용하게 된다.
   			따라서 멤버변수(전역변수)에는 데이터가 기억되지 않을 수 있다.
   			이 때, 굳이 이 변수가 멤버변수임을 반드시 밝혀야하는 경우가 생기면 강제로 this라고 써주면 된다.
   			
   			

   	속성
   	
   	 1. static 속성
   	  : static 영역에 생기는 함수나	변수에 붙여줌
   	  
   	 	+) 클래스, 함수, 변수를 만들 때 속성을 지정할 수 있음
   		 ex) 접근지정자    (속성)   class    클래스이름    {}
   		 	 접근지정자    (속성)   반환값타입     함수이름(매개변수 리스트)   {}
   		 	 접근지정자    (속성)   데이터타입     변수이름;
   		 	 
   	   
   	  static 영역의 특징
   	   
   	   1) 프로그램이 실행되기 위해서 JVM이 로딩되는 순간 저절로 생기는 영역
   	   	  즉, 사용자가 특별히 만들어달라고 요구하지 않아도 자동적으로 생김
   	   	 (JDK 설치 시 JVM이 실행되고 있음)
   	   	 
   	   2) 한 번 생긴 변수나 함수는 두 번 다시 생기지 않는다.
   	   
   	   
   	  	static 변수 
   	    	: static 영역에 만들어지는 변수
   	    
   	    	형식 = 접근지정자     static    (다른 속성)    데이터타입    변수이름; 
   	    
   	    	ex) public static final int BLACK = 1004;
  			 	    
   	    	<특징> 
   	    		- 여러 객체가 공동으로 사용하는 변수 
   	    			(객체를 100개 만들어도 static 변수는 static 영역에 한 번만 올려지기 때문.
   	    			 따라서 한 객체가 데이터를 바꾸면 다른 객체들도 바뀐 데이터를 사용해야 한다.
   	    			 결국 static 변수는 객체의 의미가 없다. 객체가 없어도 사용할 수 있다.)
   	    		
   	    		- new 시키지 않아도 사용 가능
   	    		 	(이미 static 영역에 올려져 있기 때문)
   	    		 	
   	    		 	
   	        <사용방법>
   	        	
   	        	클래스이름.변수이름;
   	        	클래스이름.함수이름(데이터);
   	        
   	    ++) static 멤버에는 this를 붙일 수 없다.
   	    
   	    
   	    
   	    
   	     static 함수
   	     	: static 영역에 만들어지는 함수
   	     	  객체를 만들지 않아도(new 시키지 않아도) 사용할 수 있는 함수
   	     	  
   	     	 형식 = 클래스이름.함수이름();
   	     	 
   	     	 <특징>
   	     	 	- this 사용 불가
   	     	 
   	 ==> static 함수 안에서는 메모리에 올려진 것들만 사용 가능
   	     일반함수 안에서는 static 멤버 그리고 일반 멤버도 사용 가능
   	     
   	     
   	     
   	     
  멤버 변수의 초기화
  
  	: 멤버 변수는 Heap 영역에 생기므로 자동 초기화가 된다. (기본 데이터 타입 = 0, 참조형 = null)
  	  하지만 가끔은 변수에 기본적인 값을 지정할 필요가 있다.
     
     방법
     	1) 명시적 초기화
     	   : 변수 선언하면서 값을 대입하는 것
     	     가장 먼저 실행되는 방법
     	     
     	     ex) class Test {
     	     		int no = 10; // 명시적 초기화
     	     	 }
     	
     	2) 초기화 블럭 이용한 초기화
   			: 인스턴스 변수에 한해서만 가능한 방법 
   			  두 번째로 실행되는 방법
   			  
   			 방법 = {
   			              이 안에 데이터를 변수에 입력;
   			        }
   			              
   			            	
     	3) static 블럭 이용한 초기화
     	 	: 2번과 마찬가지로 static 변수에 한해서만 가능한 방법
     	 	  두 번째로 실행되는 방법
     	 	  
     	 	  static { 
     	 	  			데이터입력
     	 	  		}
     	 	  		
     	 	  ex) class Test {
     	 	  		static int no;
     	 	  		
     	 	  		static {
     	 	  			no = 100;
     	 	  	 	}
     	 	  	 }
     	 	  
     	
     	4) 생성자 이용한 초기화  	 	     
   	     	 : 가장 마지막에 실행되는 방법
   	     	 
   	     	 ex) class Test {
   	     	 		int no;
   	     	 		
   	     	 		public Test() {
   	     	 			no = 100; // 생성자 이용한 초기화
   	     	 		}
   	     	     }    
   	     	     


객체지향언어의 특징
	
	1. 상속
		
		: 이미 만들어진 클래스의 기능을 그대로 부여받아서(변수와 함수의 기능을 그대로 복사해와서) 새로운 클래스를 만드는 방법
		  
		  소프트웨어 개발 속도를 빠르게 하기 위한 방법 중 하나
		  상속은 객체지향에서 매우 중요한 역할을 하는 것으로 객체지향언어는 부품 단위(클래스)로 프로그램을 만든 후에
		  그 부품을 조립해서 원하는 결과를 얻어내는 것을 의미
		  어딘가에서 부품(클래스)을 구했는데 그 기능이 사용자 마음에 들지 않을 경우
		  처음부터 다시 만드는 것은 비효율적이기에 개발된 방법이 바로 상속.
		  
		  상속은 자신이 만들고자 하는 부품과 가장 유사한 부품을 가지고 와서 일단 그 기능을 다 복사한 후 
		  	 
		  	 1) 없는 기능은 더하고
		  	 2) 수정할 기능은 수정
		  
		  <형식>  
		  	
		  	:  접근지정자   (속성)   class   클래스이름    extends   복사해올클래스이름 {}
		  
		  
		  ***자바는 오직 단일 상속만 가능하다. 
		     즉, 상속은 오직 한 개의 클래스에서만 받을 수 있다.	 	 
		  	
		    ex) class NewClass extends Old1, Old2 {}  ==> (x) 
				class NewClass extends Old1 {}  ==> (o)
		
		 <용어>
		  	상속 해준 클래스 = 상위 클래스(Super Class), 부모 클래스
		  	상속 받은 클래스 = 하위 클래스(Sub Class), 자식 클래스		
			
			is a = 상속 관계에 있는 클래스를 부르는 용어
			
					class Father {}
					class Son extends Father {}
					
					==> Son is a Father가 성립된다.
					
					Father f = new Son(); ==> (o)
					Son s = new Father(); ==> (x) 
						Son s = (Son) new Father();
						
			has a = 어떤 클래스 안에 다른 클래스를 멤버로 가지고 있는 상태
					
					class Father {}
					class Son {
						Father f = new Father();
					}
					
					==> Son has a Father가 성립된다.
					
	
		상속 관계에 있는 경우 생성자의 역할
		
			: 하위 클래스가 생성되는 순간 상위 클래스의 객체가 자동 생성된다.
			=> 생성되는 순간 생성자 함수가 호출된다.
			   따라서 하위 클래스를 생성하면 상위 클래스의 기본 생성자 함수도 실행된다.			
			 상위 클래스의 생성자 함수는 자동 호출된다.
			 자동 호출되는 경우는 무조건 기본 생성자만 이용하게 된다.		
			 
		
		***	 
		super() : 상위 클래스의 특별한 생성자를 강제로 호출하는 기능을 가진 명령
				  현재 클래스의 생성자 함수에서 상위 클래스의 생성자를 호출하는 유일한 방법
				
			특징 
				1) 반드시 생성자 함수 안에서만 사용 가능
				
				2) 반드시 첫 줄 첫 문장으로만 사용 가능
					  	
			ex) class Father {
			 		int no;
			 		public Father() {
			 		
			 		}
			 		public Father(int no) {//오버로딩한 생성자 함수
			 			this.no = no;
			 		}
			    } 
			    
			    class Son extends Father {
			    	char ch;
			    	
			    	public Son() {}
			    	public Son(int no, char ch){//오버로딩한 생성자 함수
						super(no);
						this.ch = ch;
					}		    	
			    }
				
				
	
	함수의 오버라이딩(Overriding, 재정의)
	 : 상속 관계에 있는 하위 클래스에서 상위 클래스가 가지고 있는 함수의 기능을 수정하는 행위
	 			
				
		방법
		  
		  0) 상위 클래스의 함수가 존재해야 한다.
		  
		  1) 상위 클래스가 가진 함수의 원형(prototype)과 동일한 원형으로 만들어야 한다.
		  			
				함수의 원형(prototype) = 반환값 + 함수이름 + 매개변수 리스트
				
		  2) 접근지정자는 같거나 넓은 방향으로 기술
		  		
		  		ex) 생략 ==> 3가지(생략, protected, public)
		  
		  3) 예외 처리는 같거나 좁은 방향으로 // 추후 설명
		  
	
	  오버라이딩을 하면 내부적으로 super의 함수가 숨겨지고 재정의한 함수가 사용된다.
	   	   
		ex) 
		class Fahter {
			public void abc() {
					System.out.println("시작")
			}  		
		}
			
			==> 
			class Son extends Father {
			    public void abc() {
					System.out.println("만세")
				}
				
				void xyz() {
					super.abc(); ==> 상위 클래스의 객체가 가지는 함수 호출(시작)
					abc(); ==> 현재 클래스에서 재수정한 함수 호출(만세)
				}
			}	
			상위 클래스의 abc 함수 호출하는 방법 : super.abc();
			하위 클래스의 abc 함수 호출하는 방법 : abc();
			
				
		super 
		
		: this가 현재 실행 중인 객체 자기 자신을 기억하는 예약된 변수이듯이 
		  super 역시 자신의 상위 클래스의 객체의 주소를 기억하는 예약된 변수 		
				
			- 사용 목적 : 반드시 소속을 밝혀야 하는 경우가 생길 때 사용한다.		
						  상위 클래스 안에 있는 멤버에 접근하기 위해서 사용
						  




	2. 다형성
		
		
	Object 클래스
	 : 자바로 만들어진 모든 클래스들의 최상위 클래스 역할을 하는 클래스
	   
	   따라서 자바로 만들어진 모든 클래스는 Object가 제공하는 모든 기능(멤버 : 변수, 함수)을 자동적으로 사용할 수 있게 된다.
	 
	 
	  ex) public class Abc {} = Object + alpha
	  	  
	  	  Object o(한국인) = new Abc();(아시아인) ==> (o), 다형성
	  	  
	  	  상위클래스 변수 = new 하위클래스
	  
	  
	  	
     +)	클래스의 final = 더 이상 상속 불가라는 뜻 
	 	하위 클래스는 멤버가 상위 클래스와 같거나 더 많음 
	  	클래스 타입의 멤버가 모두 들어있으면 그 클래스 타입이라고 볼 수 있음
	 						  
		
	 	최상위 클래스를 만들어 놓은 이유 : 계층 추적을 원활하게 하기 위해
	 									   각 클래스의 족보를 정확하게 따질 수 있도록 하기 위해	
	 									   
	 									   
		자바로 만든 모든 클래스는 반드시 상위 클래스를 가지고 있다.
		우리가 지금까지 만든 클래스들도 상위 클래스를 가지고 있다.
		만약 강제로 상위 클래스를 지정하지 않으면(extends 클래스이름 이라고 붙이지 않으면) 암묵적으로 Object 클래스를 상속받아서 만들어진다.
		 									   
				
	instanceof 연산자
	: 특정 클래스를 new 시키면 주소가 만들어지는데 이 주소가 어떤 클래스 소속의 주소인지 알아내는 연산자			
	  연산의 결과는 true 또는 false로 만들어진다.
	  
	  형식 :     주소    instanceof    클래스이름			
	  의미 : 주소가 가리키는 내용이 지정한 클래스 소속인지를 물어보는 것
	        (주소가 클래스 이름의 인스턴스인가?)		
	
	    소속이라는 개념은 is a 관계를 따지는 것이다.
	    상속 관계를 따지는 개념이 소속이라는 것이다.
	    			
	    			
	    			
	3. 은닉화 / 캡슐
	    			




	    			
	package와 import
	
	
		package
		: 자바 프로그램(소스코드)이 들어있는 폴더를 자바에서 부르는 용어
		  
		  자바는 오픈소스.	
		  모든 사람이 자신이 만든 프로그램을 제공할 수 있고 그것을 모두가 이용할 수 있다.
		  그러다보니 클래스 이름이 충돌하는 문제점이 생긴다.
		  이런 문제를 해결하기 위해 만들어 놓은 한 가지 방법이 바로 패키지.
		  즉, 소스를 만드는 사람이 그 프로그램이 포함되는 폴더이름까지 정해서 프로그램을 만들도록 하는 것	
		  자바로 프로그램을 만들 때는 반드시 이 프로그램이 어떤 폴더에 저장되는지 알려주도록 해놓았다.		
		  
		  
		  
		  명령 
		   : package   폴더이름;
		   
		  
		  패키지 이름 만드는 권장 사항
		  	자신이 사용하는 도메인을 거꾸로 쓴 후 그 다음에 다시 폴더 이름을 붙여서 만든다.
		  	이 때 경로의 구분자는 /를 쓰는 것이 아니고 자바에서는 .으로 구분해서 처리한다. 		
				
          
          ex) githrd.com
              ==> com.githrd.t0310	
	
				
				
		import
		: 자신이 사용할 클래스가 어느 폴더(패키지)에 있는 것인지 밝혀주기 위한 명령
				
		   ex) 나  Sample.Test.class		
		   	   친구 abcd.Test.class
		   	   
		   	   ==> 친구의 프로그램을 쓰고 싶다 = import abcd.Test;
           		   내 프로그램을 쓰고 싶다. = import Sample.Test;
           		
           	<형식>
           		1) import 패키지경로.클래스이름;
           		   ==> 지정한 폴더의 지정한 클래스를 사용할 예정임을 밝히는 것
           		
           		2) import 패키지경로.*;
           		   ==> 지정한 경로에 있는 모든 클래스 중 일부를 사용할 예정임을 밝히는 것
           	
           		
           		2)보다는 1)을 우선 적용
           		
           		   ex) Sample.Test.java
           		   	   test.Test.java
           		   	   
           		   	   import test.Test; 
           		   	   import sample.*;
           		   	   
           		   	   ==> test 패키지의 Test 클래스를 사용함
           		   	   
           		   	   
           	<주의점>
           		
           		t1 ------- s1
           			  |
           			  |--- s2------- Test1.java
           			  |         |--- Test2.java
   					  |         |--- Test3.java
  					  |
					  |  
           			  |--- Test01.java
           		      |--- Test02.java
           		      | 	   		   	   
				
					import t1.*; => Test01, Test02만 사용할 준비를 함
					
					Test1을 사용하려면 import t1.s2.*;라고 별도로 임포트해야함
					
					* 기호를 사용한 import 명령은 하위의 패키지 내의 클래스까지 사용할 준비를 하는 것이 아니고
					직속 클래스만 사용할 준비를 하는 것
				
			
			import 하지 않아도 명시적으로 사용할 수 있는 패키지는 java.lang 패키지(JVM이 기본적으로 찾아봄)
				ex) math, print, String
			
			
			
			static import
			 : static 멤버는 원칙적으로    클래스이름.멤버이름   로 사용한다.
			  이 때 static 멤버 앞에 사용하는 클래스이름조차도 생략할 수 있는데 이처럼 static 멤버를 사용할 때 클래스 이름 생략 가능하도록
			  하는 방법이 static import
			   
			  Math.PI
			  Math.random()
			  
				형식 : import static 패키지경로.클래스이름.*;		  
					 
					 random() ==> Math 클래스의 random() 함수를 호출하게 된다.   	
				
				
				
				
	final 속성
	
	 	1) 변수 : 값을 수정할 수 없는 변수(상수), 현재 값을 유지해야만 하는 변수, 선언과 초기화 동시에 이루어짐
	 	
	 	2) 함수 : 오버라이드(함수의 재정의) 불가능, 매우 중요한 함수이므로 함부로 기능을 바꾸지 말고 현재 기능 그대로 사용하라.
	 	
	 	3) 클래스 : 상속 불가능한 클래스, 기능을 추가 혹은 변경하지 말고 현재 기능 그대로만 이용하라   			
	
	
	
	
	
	상위 클래스의 타입 변수로 하위 클래스의 인스턴스를 기억하는 경우
	변수는 레퍼런스 쪽(처음 값)을 따르고 
	함수는 인스턴스 쪽(마지막 값)을 따른다. (Test05)
	단, 레퍼런스 쪽에 실행하려는 함수가 존재해야 한다.
		
   	     	     
   	     	     
   	     	     
   	     	     

   	     	     
   	     	 
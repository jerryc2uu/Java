#day12

<정리>

 상속 : 하위 클래스에서 상위 클래스의 기능을 수정하는 것
 	
	참조형 변수의 경우, 타입을 결정하는 것은 인스턴스에 변수 쪽 클래스의 멤버가 모두 있는지 여부
	
	하위 클래스 멤버 수(좁은 방향, 한국인) > 상위 클래스 멤버 수(넓은 방향, 아시아인)

	
 오버라이딩 : 함수의 재정의
 	0.
 	1. 함수의 원형(반환값타입/함수이름/매개변수 리스트) 일치
 	2. 접근지정자는 같거나 넓은 방향 
 		(클래스 : 생략, public / 함수 : 4개 )
 	3. 예외 처리는 같거나 좁은 방향

 상속 관계에 있는 경우, 상위 클래스의 변수에서 함수를 호출하게 되면
 최종적으로 하위 클래스에서 오버라이딩한 함수(수정한 함수)가 호출된다. 
 
 변수는 레퍼런스 (이전 값)
 함수는 인스턴스 (이후 값)
----------------------------------------------------------------------------------------------------------------------------------------

	다형성
	
	: 하나의 변수를 이용해 여러 형태의 클래스를 사용하도록 하는 방법
	  상위 클래스의 변수를 이용해서 하위 클래스의 인스턴스를 이용하는 것
	  
	  -> 상위 클래스의 변수 하나로 여러 하위 클래스의 인스턴스를 다룰 수 있음 
	 	 하위 클래스의 인스턴스는 상위 클래스의 레퍼런스로 사용 가능
	 	 
	 	 클래스의 인스턴스 타입을 따질 때는 그 인스턴스에 해당 클래스의 멤버가 존재하는지 여부를 따지
	 
	 
	 	사용 방법
	 	 1. 어떤 함수가 상위 클래스를 매개변수로 가지고 있으면 하위 클래스의 인스턴스를 입력해도 상관없다.
	 	 	만약 어떤 함수가 Object 타입으로 매개변수가 정의돼 있으면 이 경우 Object 클래스의 인스턴스를 만들어서
	 	 	함수를 호출하는 경우는 없다. 일반 클래스 넣으면 된다.
	 	 	이 함수는 모든 클래스들의 인스턴스를 매개변수로 입력해도 되는 함수
	 	 	자바의 모든 클래스는 Object 타입으로 자동 형변환 가능하니까.
	 	 	
	 	 2. 어떤 함수가 상위 클래스를 반환값으로 가지고 있으면 반드시 원하는 하위 클래스 형태로 형변환해서 사용해야 한다.
	 	 
	 	 
	 	 어떤 반환값이나 넘겨받은 데이터의 타입이 Object인 경우 그 데이터를 연산하려면 반드시 원래 타입으로 강제 형변환해줘야 한다. 
		 	 	 
	 	 		 
	 	 
		
	
	Casting(주소의 형변환) : 원칙적으로 주소는 다른 형태로 형변환이 불가능.	Heap Type 형태에 따라 주소가 결정.
 	 						 Heap 형태가 다르면 주소를 기억할 수 없음.
 	 						 유일하게 상속 관계에 있는 클래스끼리(is a 관계)는 주소의 형변환이 가능.
 	 						 
 		
 			ex)  int[] num = new float[10]; (x)
 			     Test t = new Sample(); ==> 상속 관계 아닌 경우 (x)
 			     						    상속 관계인 경우 (o)
 			     						    
 		- 자동 형변환 : 하위 클래스 주소가 상위 클래스 변수에 기억되는 것은 자동 형변환
 		- 강제 형변환 : 상위 클래스 주소가 하위 클래스 변수에 기억되는 것은 강제 형변환
 		
 		ex) class Father {
 		
 			}
 			
 			class Son extends Father {
 			
 			}
 			
 			Father f = new Son(); ==> 자동 형변환
 			
 			
 			Son s = new Father(); (x)
	
			Father f1 = new Father(); 
 			Son s = (Son) new f1(); ==> 강제 형변환	     				
 			
 			
 			
 			
 			
 			
 	 <추상 클래스> 
 	 
 	 : 추상 함수를 0개 이상 가지고 있는 클래스 (없어도 강제로 추상 클래스 만들 수 있고, 1개라도 있으면 반드시 추상 클래스로 만들어야 함)
 	 
 		형식 : 접근지정자     abstract     class     클래스이름 {
 					변수 선언;
 					일반 함수() {}
 					
 					추상함수(); // 없어도 됨
 				}  	
 	 	
 	 	사용 목적 : 다형성 구현
 	 	
 	 	사용 방법 : 추상 클래스 자체를 new 시킬 순 없음 (기능 없는 함수가 존재하니까)
 	 			
 	 			1. 상속 후 하위 클래스에서 추상함수의 기능(블럭)을 만들어주고 하위 클래스를 new 시켜서 
 	 				추상 클래스의 변수에 담아 사용
 	 			
 	 		*	2. 추상 클래스 안에 속성이 static이면서 반환값이 자기 자신인 함수를 호출해서 인스턴스를 얻어 사용
 	 			
 	 				ex) Calendar 클래스
 	 						
 	 						Calendar cal = Calendar.getInstance();
 	 						
 	 						==> 함수가 Calendar 인스턴스를 반환해줌
 	 				
 	 				
 	 		+) 추상 클래스가 아닌데도 생성자 함수가 없는 것처럼 보이는 클래스 
 	 			: 생성자의 접근지정자를 private(그 클래스 안에서만 사용)으로 감춰둔 것		   
 	 				
 	 			new 시켜서 사용 불가, 추상클래스의 2 방법처럼 사용
 	 			해당 클래스에 없을 경우 관련 클래스에서 함수를 찾아 쓴다.
 	 	
 	 	
 	 	
 	 	
 	 	
 	 	추상 함수 : 블럭이 없는 함수, 기능이 없음 (기능이 어떻게 될지 알 수 없기 때문)
 	 		
 	 		형식 : 접근지정자    abstract(=속성, 변경불가)    반환값    함수이름(매개변수 리스트);  
 	 		
 	 		ex) public   abstract   void    abc(int a);
 	 			
 	 			
 
 	
 	<인터페이스(Interface)>
 	
 	: 특수한 클래스
 	
 		특징 
 		
 			1) 최상위 클래스 없음 = 인터페이스는 다른 클래스 상속받아 만들어진 클래스가 아님
 			
 			2) 인터페이스 내에는 반드시 추상함수가 한 개 이상 존재, 일반함수(기능이 구현된 함수) 존재x
 				==> 인터페이스 내에서는 접근지정자와 속성을 기술하지 않아도 public abstract가 자동적으로 붙여지게 됨
 			
 			3) 다른 클래스에 (다중) 상속 가능
 				==> 여러 인터페이스의 함수를 오버라이딩해서 클래스 구현 가능
 			
 			4) public static final 변수만 가질 수 있음
 		
 		
 		
 		
 		+)	
 			추상 클래스 : 추상 함수 ㅇ, 일반함수 ㅇ
 			인터페이스  : 추상 함수 ㅇ, 일반함수 x	
 			 
 	 			
 	 	사용 목적
 	 		
 	 		: 	함수의 기능을 개발자가 정하기 위해서
 	 		
 	 	
 	 	사용 방법
 	 
 	 		: new 불가능 ( = 추상 클래스)
 	 		
 	 		1) 일반 클래스에 구현 (90%)
 	 			
 	 			class  클래스이름  (extends  상속해줄클래스)   implements   인터페이스이름,   인터페이스이름 ....
 	 			
 	 		- 하위 클래스에서 인터페이스의 함수 모두 오버라이딩
 	 			==> 인터페이스 소속 함수의 접근지정자가 public인 이유
 	 			
 	 		- 하위 클래스를 new 시켜서 사용
 	 		
 	 		
 	 		2) static, 해당 인터페이스타입인 함수 사용 (10%)
 	 		
 	 			추상 클래스는 그 안에 해당 함수가 있으나
 	 			인터페이스는 해당 함수가 없기 때문에 다른 클래스에서 찾아 사용
 	 				
 	 				
 	 				
 	------------------------------- 				
 	 +) 인터페이스끼리도 상속 가능
 	 	
 	  	interface   새로운인터페이스이름    extends    상속해줄인터페이스이름 {}	
 	 	
 	 +) 인터페이스 안에 일반 함수가 오는 경우
 	 	함수의 속성은 모두 default라고 명시	
 	 		
 	 		
		default   반환값타입   함수이름() {} 	 		
 	---------------------------------- 		
 	 		
 	 	
 	 	
 	 	
 	 	<내부 클래스(Inner Class)>
 	 	
 	 	: 클래스 안에 다시 만든 클래스(블럭 안에서 다시 클래스를 정의)
 	 	
 	 	
 	 	목적 : 클래스 내용이 짧을 경우 내부 클래스 활용
 	 	
 	 	
 	 	종류 
 	 		
 	 		1. Top Level Inner Class : 독립적으로 활동하는 내부 클래스  (내부, static)
 	 			
 	 			형식 =  static   class   클래스이름(바깥클래스이름.내부클래스이름) {}
 	 			
 	 			+) 클래스 이름 = "바깥클래스이름.내부클래스이름"
 	 			
 	 		
 	 		

 	 	*	2. 전역 Inner Class : 일반 클래스로 만든 내부 클래스 
 	 		
 	 			형식 =  class   클래스이름   {}	
 	 		
 	 			특징
 	 			
 	 			1) 바깥 클래스의 멤버 사용 가능
 	 			
 	 			2) 바깥클래스 new 시킨 후 내부클래스 생성 가능, 이후 다시 내부클래스 new 시킨다.
 	 			
 	 				형식 = 바깥클래스주소.new 안쪽클래스이름();	
 	 			
 	 			3) 바깥 클래스는 내부 클래스의 멤버 사용 불가능 (new시켜야만 사용 가능)
 	
 				==> 바깥 클래스와 연관된 기능을 가진 클래스를 만들고 싶을 때 사용 			
 	 			



 	 			
 	 		3. 지역 Inner Class : 바깥 클래스의 함수 안에서 만든 내부 클래스
 	 		
 	 			형식 = 
 	 	
 	 			ex)  class Test {
 	 					int a;
 	 					class Inner {}  // 전역 내부 클래스
 	 					
 	 					void abc() {
 	 						int no = 0;
 	 						
 	 						class Inner02 { // 지역 내부 클래스
 	 						}
 	 					}
 	 				}
 	 	
				특징
				
				1) 바깥 클래스 멤버 사용 가능
				
				2) 함수 안에서만 new 가능
				
				
					 	
 	 	    
 	 	
 	 		
 	 	*	4. 무명 Inner Class : 이름 없는 내부 클래스
 	 	

 				목적 : 간단하게 클래스 제작, 클래스 new 시키는 순간 오버라이딩해서 사용 


 				오버라이딩 or 인터페이스/추상클래스
 				-> 상속 받아서 하위 클래스 만들고 그 클래스를 객체로 만든 후 사용하는 게 원칙
 				
 				
 				
 				ex)	 System.exit(0);  ==>   프로그램 종료  			
 	 		
 	 		
 	 			형식 =   new   인터페이스이름() {
 	 							추상함수 오버라이딩
 	 					} 
 	 					
 	 					
 	 					new   추상클래스이름() {
 	 							추상함수 오버라이딩
 	 					}
 	 			
 	 		
 	 		
 	 		
 	 		
 	 		
 	 			
 	 			    
 			     						    
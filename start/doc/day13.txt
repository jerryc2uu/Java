#day13


<오버라이딩 규칙>
1. 함수의 원형 유지 (반환값타입 함수이름 매개변수리스트)
2. 접근지정자는 같거나 넓게
3. 예외처리는 같거나 좁게




<예외처리> : 예외가 발생했을 때 대처하는 방식의 프로그램

프로그램상 문제 없으나 데이터나 장비 문제에 의해 발생하는 에러를 "실행 에러(Run Time Error)"라고 표현하고
이것을 자바에서는 "예외(Exception)"라고 말한다.

예외가 발생했을 때 대처하는 방식의 프로그램을 예외처리라고 부른다.

자바에서는 예외 발생 원인을 개발자가 알고 있어야 한다는 문제를 해결하기 위해 예외처리 문법이 존재한다.



	ex)
	
		(1)
		
		실행명령
		
		(2)
		
		==> 이 경우 실행명령에서 에러가 발생하면 (2)는 실행하지 않고 이 프로그램은 비정상 종료가 된다.
	
	
	
	

	형식
	 
		(1)
		try {
			(2)
			.....     ==> 예외가 발생할 여지가 있는 코드가 있는 장소
			(3)j
		} 
		
		catch(???) {
			(4)		  ==> 예외 발생 시 문제점을 해결하는 부분
		}
		
		finally {
			(5)		  ==> 예외 발생 여부와 관계 없이 반드시 실행되는 부분
		}
		(6)
		
		
		
	실행순서
	
		(1) - (2) - ...(예외 발생 안 한 경우) - (3) - (5) - (6)
					...(예외 발생한 경우) - (4) - (5) -(6)
		
	주의
	
		(3) 위치는 바로 위의 실행 명령에 예외가 발생하면 실행되지 않는다.
		따라서 try{} 범위에 따라서 실행될 수도 있고 안 될 수도 있다. 
			
			
		ex)
			try {
				파일 오픈 ==> 파일이 없다면 에러 발생
				}
				파일의 내용을 읽는다.
				그 내용을 화면에 출력한다.
				
		
		
	+) finally 블럭은 예외 발생 여부와 관계 없이 실행되는 부분이지만 생략 가능 
	   
	   finally 블럭이 있는 경우 catch 블럭은 드물게 생략해줄 수 있다.	
		
		
		
   원리 : 예외 발생 시 JVM이 예외의 종류 분석 후 예외에 대한 정보를 객체로 만들어서 catch 부분에 그 주소를 전달한다.	
		
	

	catch 블럭	: 예외 발생 시 그 정보를 받아서 개발자가 원하는 처리를 해줘야 한다
	
	다중 catch 블럭 : try {} 안에 다양한 예외 발생 요소가 존재 
					  어떤 에러 때문인지 구분해서 처리해야 하는 경우 사용하는 문법	
		
		형식
			
			try {
			}	
			catch(예외클래스의매개변수){
			}
			catch(???){
			}
			...	
		
		
	***	주의
			
			다중 catch 사용 시 반드시 실행될 수 있는 상태로 만들어야 한다.
			좁은 범위의 catch가 먼저 기술되어야 한다. (else if 구문과 마찬가지)
			
			
			
	예외정보 출력
		
		예외 정보 얻기
		
			1. 예외정보 클래스 변수 출력	
				
				ex) System.out.println(예외정보클래스변수); ==> 자동으로 toString 함수 호출, 문자열 출력 = 예외 원인 파악 가능
				
		*	2. 예외클래스변수.printStackTrace()를 이용
				
				: 예외 정보 + 예외 발생 위치 + 경로 추적해서 출력
	
	
	예외처리 목적
	
		: 프로그램의 정상적인 종료 (실행해야 하는 코드 모두 진행하고 종료하도록)			
				
		예외처리는 예외가 발생하면 개발자가 그것을 수정해서 정상적으로 동작하도록 만드는 행위 
		이는 매우 어려우며 드문 일이다.
		
		다만 예외처리의 실제 이유는 예외의 정보를 알아서 사용자에게 프로그램에 문제가 생긴 이유를 알려주고
		그 프로그램을 정상적으로 종료되도록 하는 것
		
		
		
		
		
<예외 전이> : 예외에 대한 처리를 다른 쪽을 떠넘김

함수는 프로그램의 가장 작은 단위, 한 가지 작업을 하기 위해서 만든 것
따라서 함수 안에서 작업을 하다가 예외가 발생하면 그 함수는 더이상 실행할 필요가 없는 경우가 많다.
따라서 함수는 예외를 전이하도록 해 놓은 경우가 있다.
		
	
	형식 
		
		접근지정자   (속성)   반환값타입    함수이름(매개변수리스트)   throws   예외클래스1, 예외클래스2,... {}
				
				
	의미
		
		지정한 예외가 발생하면 이 함수는 더 이상 실행해도 의미가 없으므로 실행을 중지하라				
		
		
  * +) 예외가 전이된 함수는 반드시 그 함수를 호출한 곳에서 예외 처리 해줘야 한다.
 
 	+) 비록 어떤 함수가 예외를 전이하는 함수라도 예외 처리를 하지 않아도 되는 경우가 있다.
 		
 		전이하는 예외가 RuntimeException의 하위인 경우에는 예외처리 여부 상관 없음 (java.lang 패키지 소속 클래스 함수들)
 		그래도 해주는 것이 좋다.
 		
 		
 		
 		
 		
 <강제 예외 던지기> : JVM은 예외로 인정하지 않지만 프로그램의 목적 상 예외로 인정해야 하는 경우 개발자가 JVM에게 강제로 알려주는 방법
 
 
 	ex) 나이는 음수를 입력하면 안 된다.
 		
 
 	형식 
 		
 		throw	new	 예외클래스이름();
 		        -인스턴스 만드는 방법-           
 		        
 		        
 	주의
 	
 		예외전이   : throws  예외클래스
 		예외던지기 : throw  new  예외클래스();  
 		
 		
 	
 	사용자 예외 클래스 : 
 	
 	예외 클래스는 예외의 발생 원인을 알려주는 역할을 담당. 
 	그런데 앞에서 강제 예외 던지기는 자바가 준비한 예외가 아니므로 예외의 원인을 파악하기가 어렵다.  
 	사용자가 예외 정보를 만들어주는 클래스를 따로 만들어서 사용할 수 있다.
 	       
 	       
 	       방법 
 	        	
 	        	1. Exception 클래스를 상속 받은 클래스를 만든다.
 	        	
 	        	2. toString()를 오버라이딩 해서 예외의 원인을 출력할 수 있도록 한다.
 	        	
 	        	

 	        	
#day14


<오버라이딩 규칙>

	1. 함수 원형 유지
	2. 접근지정자 같거나 넓게
	3. 예외 처리 같거나 좁게
	
	4. 예외 전이 함수는 throws 하는 예외가 같거나 줄어들 수 있다.
	   상위 클래스에서 던지지 않은 예외를 던지면 안 된다.
		
		ex) void add(int a, int b) throws InvalidNumberException, NotANumberException {}
		   
		    void add(int a, int b) throws InvalidNumberException, NotANumberException {}  ==> (o)  :  같음
		    
		    void add(int a, int b) throws InvalidNumberException {}  ==> (o)  :  예외의 갯수 줄어듦
		    
		    void add(int a, int b) throws Exception {}  ==> (x)  :   예외의 범위가 넓어지면 안 된다.
		    
		    void add(int a, int b) throws NumberException {}  ==> (x)  :  상위 클래스 함수에서 던지지 않은 예외는 안 된다.
		    
		    

------------

<피연산자 동등비교연산자 피연산자 (a == b)>

기본형 타입 : 데이터 자체 비교		    
int a = 10;
int b = 10;

a == b

레퍼런스(클래스) 타입 : 주소 비교
Abc a = new Abc();
Efg e = new Efg();


class Nemo {
	int width, height, area; (Nemo 클래스의 속성)
}

Nemo n1 = new Nemo(10, 20);
Nemo n2 = new Nemo(20, 10);
		    
n1 == n2  (x)  :  주소 비교		

	
	
<Object Class> 
	
	: 자바로 만든 모든 클래스의 최상위 클래스
	  상속 관계를 명확하게 하기 위한 역할	
	  
	  
	- 소속 함수
	
		1. equals() : 내용이 아닌 주소 비교 함수 (문자열 데이터 비교) 
		
			
			- 클래스(메모리에 올리는 최소한의 단위) 사용 방법
			
				1. 객체로 만든다 = Heap에 내용을 올린다.
				
  					클래스이름 변수 = new 클래스이름();
  					
  				2. 변수(주소) 이용해 내부 멤버들을 사용
  					
  	
  			- String 클래스의 equals()는 Object 클래스가 물려준 함수를 오버라이딩해서 내용을 비교하는 기능으로 바꾼 것
  			
  			- 다른 클래스에서도 equals()를 오버라이딩 해서 기능을 수정하면 내용을 비교할 수 있을 것이다.
  			
  		
  		
  		2. toString() : 주소 출력 함수
  		
  		자바는 주소를 내부적으로 사용하지만 이를 개발자에게 노출하지 않는다. 그래서 변수에 주소를 기억시켜놓는 것
  		대신 주소(변수가 기억하고 있는 것)를 출력하면 "클래스이름@해쉬코드값"의 형태로 출력하게 된다.
  		
  			- 해쉬코드 값 : 자바는 주소를 내부적으로 해쉬테이블을 이용해서 관리
  							해쉬코드 값은 그 주소를 관리하는 해쉬테이블의 코드값이 된다.
  							주소를 출력하면 내용이 아니라 해쉬코드 형태의 코드값이 출력된다.
  							이것은 이런 형태의 문자열을 만들어서 반환해주는 기능의 함수가 자동 호출되어서 출력되는 것이다.
  							이때 자동호출되는 함수가 toString() 이다.			
							만약 우리가 만든 클래스에서 주소(변수)를 출력할 때 해쉬코드 값이 아닌 우리가 원하는 데이터(내용)로
							출력하려면 toString()을 오버라이딩해서 원하는 형태로 문자열을 반환해주도록 하면 된다.
							
		
		
		3. clone() : 자신을 깊은 복사해주는 함수
					
					 접근지정자 protected = 상속 받은 하위 클래스 + 같은 패키지 내 클래스
					 
		
		
		4. hashCode() : 해쉬테이블에 주소를 관리하는 코드값을 알려주는 함수
		 
------------

	<알아두면 유용한 클래스들>
	
	
	1. String : 간단한 문자열 관리
	
		* 단점 : 내용 변경 시 이를 새로 메모리에 저장하고 주소도 바꾼다.
				 내용 변화가 심하면 결합할 때마다 데이터가 메모리에 쌓여서 메모리 낭비가 심함
				 
				 => 내용 변화가 심한 문자열은 StringBuffer, StirngBuild 사용
				 	간단한 문자열 처리는 String 사용, 유일하게 new 시키지 않아도 되는 클래스.		 
			
					Ex) String str = new String("홍길동");
						String name = "홍길동";
						
		- 유일하게 함수가 아닌 연산자(+)를 사용해서 결합 연산을 처리할 수 있는 클래스
		
		- String 소속 함수는 자신이 기억한 데이터 자체를 변경할 수 없다. 연산된 결과를 반환해주는 것일 뿐. 
		
	
	2. StringBuffer : 복잡한 문자열 관리
		 				
		* 장점 : 내용 변화 생기면 같은 메모리에 이를 덮어씌운다.
		
		- 사용법  
			
			1) 객체 생성  
				
				StringBuffer buff = new StringBuffer("문자열"//너무 길면 생략도 가능);
			
			2) 만들어진 객체에 문자열 결합
				  
				buff.append("문자열"); 
				
			3) 문자열 데이터가 필요한 순간 문자열로 변환
			
				String str = buff.toString();		
				
				
	3. StringTokenizer : 문자열을 특정 구분자를 기준으로 자른다. 	
		
		* 주의 : 분리된 결과물은 배열과 같은 형태로 버퍼메모리에 기억된다.  
				 기억된 내용을 접근해서 한 번 사용하면 사라진다.
				 
		- 사용법
		
			StringTokenizer token = new StringTokenizer("문자열", 구분문자);	
			
			while(token.hasMoreElement()) {
				//하나씩 꺼내서 작업, 더 이상 꺼낼 게 없을 때까지
				Object o = token.nextElement();
				String str = token.nextToken();
			}
		
		
		

	 4. Math 클래스 : 주로 수학적 기능을 처리하는 함수로 구성된 클래스
					멤버들이 모두 static 멤버이므로 굳이 new시키지 않아도 사용 가능한 클래스
					아예 new 시키지 못하도록 해놓은 클래스
							
					+) 클래스 안의 멤버들을 쓰려면 클래스를 new 시켜서 멤버들을 메모리에 올려야 하는데 Math클래스는 예외	
		
	 
	 
	 
	 5. 래퍼 클래스(Wrapper Class) : 기본 데이터 타입 8개를 객체로 만들어 주기 위한 클래스
	  						
	 								 Heap에 만들어진 주소를 사용하는 (클래스 타입의 데이터를 사용하는) 곳에서 Value Type(기본 데이터 타입)을 
	 								 사용할 수 없는 문제가 발생.
	 								 이런 문제를 해결하기 위해 만든 클래스
	 	
	 
	  				
	  				+) 기본 데이터 타입들은 자바에서는 객체가 아니다. 안에 멤버(함수)를 갖고 있지 않다.
	  								
	  					ex) -1 이라는 데이터가 함수를 갖고 있지는 않다.
		
					
					+) 자바는 Object 클래스를 중심으로 계층 구조화해서 클래스를 이용하도록 만든 객체지향언어
					
						모든 타입은 Object 타입으로 자동형변환 되는데 기본 데이터 타입은 Object 타입으로 자동 형변환이 되지 않는다.
						
						Ex) Object o = 100;  (x)

						즉, 모든 데이터는 Object 타입에 담을 수 있다. 
						
						그러나 Value Type(기본 데이터 타입 : boolean, char, byte, short, int, long, float, double)은 객체지향 원리를 사용하지 않는다.
						
						따라서 다형성 구현에 있어서 문제가 발생.
						
						ex) void abc(Object o) {
						
							}
							
							=> 이 함수는 모든 데이터를 처리할 수 있는 기능으로 만들었음에도 불구하고 
								기본 데이터 타입의 데이터는 이 함수로 처리 불가 	
		
		------------------------------------------------------------------------------------------------------						
			종류
				
				1) Boxxing : 기본 타입을 참조형 타입으로 변환하는 것  
				
				2) UnBoxxing : 참조형 타입의 데이터를 기본형 타입으로 변환하는 것 											
								(Heap 영역에 있는 데이터를 다시 Stack으로 꺼내는 것)
		
			
			=> 래퍼 클래스란 박싱과 언박싱을 해주기 위한 클래스
		
		
					  +) 자바 버전 1.4 이후부터 박싱과 언박싱이 자동으로 처리된다. 
				
				ex) Integer no1 = 10; // 자동 Boxxing
					
					int num = no1; // 자동 UnBoxxing  
					
					매개변수 object에 10을 담는 경우엔 Integer 타입으로 박싱해줘야 한다.
					
					
			 기본 데이터 타입			  객체로 만들 때 클래스이름
					boolean		<------->	Boolean
					char		<-------> 	Character
					byte		<-------> 	Byte
					short		<------->	Short
					int			<------->	Integer
					long		<------->	Long
					float		<------->	Float
					double		<------->	Double
		--------------------------------------------------------------------------------------------------------
		
		
		
		
	  <java.util 패키지 소속 유용한 클래스들>
	  
	  
	  
	  1. Objects : 100% static 함수로만 구성된 클래스 (new 필요없음, 이미 static 영역에 올라가있으니까)
	  				
	  				클래스(객체)를 다룰 때 유용한 몇 가지 유틸리티적 함수로 구성된 클래스
	  				
	  
	  		ex) isNull(Object obj) : 객체 내용 있는지 확인하는 함수, new 시킨 결과가 있는지 확인, 인스턴스 유무 확인
	  		
	  			
	  			+) null : 참조형 변수에 주소가 없는 상태, 찾아갈 대상이 없다는 의미 
	  					  아직 사용할 준비가 되지 않았다는 의미
	  					  Heap에 만들어진 인스턴스조차 없다는 의미
	  					  
	  					  
	  
		
		
		
		
		
	

				
			 			 
							
							
							
							
							  		
  						
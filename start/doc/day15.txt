#day15

	<Math클래스> 	 
	
	final class : 상속 불가 (모든 멤버를 그대로 쓰라)
    private Math() {} // 생성자가 private으로 감춰져 있어서 외부에서는 new 절대 사용 불가(new 시키지 말아라)
	
	
	<null> : 참조형 변수 선언만 한 상태, 힙에 인스턴트가 만들어지지 않은 상태 
			
		   
		   기본형 타입 배열은 자동 초기화된 데이터 존재
		   
		   ex)
			   char 아스키코드값0
			   double 0.0
		   
		   참조형 타입 배열은 아무것도 없는 null 상태
		   따로 객체를 만들어서 채워줘야 한다.
		   
		   ex) String[] tboyz;
		   
		
---------------------
	<java.util 패키지 소속 유용한 클래스들>
	  
	  
	  
	  1. Objects : 100% static 함수로만 구성된 클래스 (new 필요없음, 이미 static 영역에 올라가있으니까)
	  				
	  				클래스(객체)를 다룰 때 유용한 몇 가지 유틸리티적 함수로 구성된 클래스
	  				
	  
	  		ex) isNull(Object obj) : 객체 내용 있는지 확인하는 함수, new 시킨 결과가 있는지 확인, 인스턴스 유무 확인
	  		
	  			
	  			+) null : 참조형 변수에 주소가 없는 상태, 찾아갈 대상이 없다는 의미 
	  					  아직 사용할 준비가 되지 않았다는 의미
	  					  Heap에 만들어진 인스턴스조차 없다는 의미
	
	
	
	
	  2. Random : 난수를 발생하는 클래스
	  			  
	  		- 장점  :  Math.random()보다는 더 다양한 형태의 난수를 발생할 수 있다 
			
			+) seed : 컴퓨터에서 난수 발생 순간은 실제로 난수를 만드는 게 아니고 이미 컴퓨터 내부에는
					  난수를 기억하는 난수 테이블이 존재한다. 여기서 순서대로 꺼내서 주는 역할을 한다.
					  seed는 난수 테이블에서 난수를 꺼내는 위치를 의미		
					  
					  
					  
	  3. BigDecimal : 정수로 표현할 수 없는 숫자를 사용하기 위한 클래스
	  	
					  	정수에서 가장 큰 숫자 : long 타입 (8byte) 2^31
					  	이것보다 큰 숫자를 표현하는 클래스
					  	
					  	주로 데이터베이스와 연동할 때 데이터베이스의 숫자 타입은 
					  	오라클의 경우 NUMBER(숫자) 타입은 최대 32자리까지 사용 가능
					  	이런 형태의 데이터를 자바에서 처리하기 위해서 만든 클래스
					  	
			ex) BigDecimal big = new BigDecimal("12345678912345678901239448567"); // 숫자 형태로 못쓰기 때문에 문자열로 씀
			
			
			
-----------------------

	정규식(정규표현식) 검사	 :  주어진 문자열이 특정한 규칙에 맞도록 만들어져 있는지 확인하는 기능
								(문자열의 형식 검사)
				
											  	
			ex) 주민번호 6-7로 구성되어있는지
				아이디가 순수하게 숫자와 문자로만 구성되어있는지
				아이디가 최소 몇 글자 이상으로 만들어져 있는지
				
				모든 언어에 다 있으나 각 언어마다 사용법엔 차이가 있다.
				
				
				
			- 사용하는 클래스 
				
				: java.util.regex.Pattern = 정규식 검사에 사용할 정규식 문법을 지정할 클래스
				  
				  java.util.regex.Matcher = 정규식 검사를 실제로 실행할 클래스					
					
			
			
			+) 정규표현식 문법
				
				1. c[a-z]*  :  문자를 기록하면 반드시 그 위치에 기록한 문자가 와야 한다. c로 시작하는 문자
							   [] 안에 기록하면 그 중 하나가 와야 한다.	알파벳 소문자가 하나는 와야 한다.
							   *은 바로 앞에서 지정한 글자가 0개 이상 올 수 있다.
							   
							   => c로 시작하고 그 후에는 알파벳 소문자가 0개 이상 오면 된다는 뜻, c만 와도 됨
							   
							   
				2. c[a-z]   =>  c로 시작하고 그 다음 글자는 알파벳 소문자가 한 글자 와야 한다.
				
				
				3. c[a-zA-Z]  =>  c로 시작하고 그 다음 글자는 대소문자 알파벳 한 글자 와야 한다.
				
				
				4. c[a-zA-Z0-9]  =>  c로 시작하고 그 다음 글자는 알파벳 또는 숫자가 한글자 와야 한다.
				
				
				5. .*   :  .은 모든 문자(알파벳, 한글까지 포함)를 의미
					
						=>   어떤 문자라도 0개 이상 오면 된다.
				
				
				6. C.   =>   첫 글자는 C로 시작하고 다음 문자는 어떤 문자라도 한 글자만 오면 된다. 
				
				
				7. C.*  =>   첫 글자는 C로 시작하고 다음 문자는 어떤 문자라도 0개이상 오면 된다. (C로 시작하는 모든 문자열)
				
				
				8. C\.  :   \.은 반드시 그 위치에 .이 와야 한다는 의미
										
						=>    C. 이어야 한다.	
						
			    
			    9. c\d  :   \d는 숫자 의미
			    		
			    		=>   첫 글자는 소문자 c로 시작하고 그 다음 문자는 숫자가 와야 한다.			
							 
						==	 c[0-9]
							 
				
				10. c.*t  =>  첫 글자는 c로 시작하고 마지막 글자는 t가 와야 하는데 중간에 어떤 문자라도 0개 이상 올 수 있다.
					 	
							ex) cjkjkljkjwjlj0-at  (o)
							
							
				11. [b|c].*  =>  b 또는 c로 시작하고 그 이후에는 어떤 문자라도 0개 이상 올 수 있다.
								
							 ==	 [bc] , [b-c]		
							 
				
				12. [^b|c]   :   ^의 의미는 not. 
							
							 =>  b 또는 c 이외의 문자 한 개				
				
				
				13. .*a.*   =>	a 앞에 0개 이상 문자가 오고 a 뒤에 0개 이상 문자가 오면 됨
				                즉, a 문자가 포함된 모든 문자열
				
				
				14. .*a.+   :   * 은 0글자 이상 , + 는 1글자 이상 	
							
							=>  a 다음 적어도 한 글자 이상 와야 한다.
							
				
				15. [b|c].{2}  :  {숫자} 는 글자 수를 의미, {숫자,} 는 숫자 개 이상 의미, {숫자1,숫자2} 는 숫자 1개 이상 숫자 2개 이하의 의미
				
							   =>  b 또는 c로 시작하고 어떤 문자라도 그 뒤에 두 글자가 와야 한다.
							   
							   
				16. .{2,3}   =>  어떤 문자라도 2글자 이상 3글자 이하가 와야 한다.
				
								
								
				
					ex) 핸드폰 번호 표현식
							
							01[0-9]-[0-9]{4}-[0-9]{4}
							
						전화번호 표현식
						
							0[0-9]{2,3}-[0-9]{3,4}-[0-9]{4}
							
							
-----------------

 <컬렉션(Collection)> : 많은 양의 데이터를 손쉽게 보관할 수 있는 클래스들의 집합

	
	배열 이용 시 문제점
		
		- 길이(크기) 변경 불가
		
		- 데이터 입출력 제한 : 반드시 위치를 알아야 함
		
		
	컬렉션 종류   List와 Set은 상위 클래스가 동일(형변환 가능)
	
		1. List 계열
		
		  *	특징
			
				1) 입력 순서 보장 o (먼저 입력한 걸 먼저 출력), 느림
				
				2) 중복데이터도 다시 저장
		
		2. Set 계열 ==> 중복데이터 원치 않을 때 쓰면 편함
						객체를 정렬하려면 Comparator 인터페이스를 상속해야 한다.
		
		  *	특징
				
				1) 입력 순서 보장 x (클래스 자체에서 나름의 규칙대로 데이터를 정렬해서 보관하기 때문), 빠름
				
				2) 중복데이터 허용 x
					
					: 중복 데이터 입력 시 먼저 입력된 데이터 지우고 다시 저장
					  같은 데이터는 한 번만 저장 			
				
		
		3. Map 계열
			
			특징
			
				1) 데이터와 데이터를 구분하는 키값을 한 쌍 만들어서 저장
				
				2) 입력 순서 보장 x
				
				3) 같은 키값으로 데이터가 입력되면 먼저 입력한 데이터를 삭제한다.
		 			
		 			: 데이터는 중복 가능하나 키값은 중복 불가				
							
		
		+)	List 계열과 Set 계열은 같은 상위 클래스 공유
			
			Map 계열은 다름  
		   						
		   	List와 Set은 서로 변환 가능 (다형성 구현), Map은 독립적으로 변환이 불가능
		   	
		   	 




	<List 계열>
	
		
		1. Vector : 내부적으로는 배열 형태를 만들어서 데이터를 보관하는 컬렉션의 일종
		
			장점
				
				- 입력, 검색 속도 빠름
				
			단점
	
				- 중간에 데이터 삽입하거나 삭제하는 속도 느림
				
		***	==> 데이터 변화가 거의 없는 프로그램에서 사용
		
		
			생성방법
				
				1) Vector() 
					
					: 배열 크기를 10으로 정한 상태로 벡터를 만든다. 
					  데이터가 많으면 크기 자동 변경 ( 이전 크기 * 2 )
				
				2) Vector(Collection c)
				
					: 다른 컬렉션의 데이터를 복사해서 벡터를 생성 
					
				3) Vector(int initialCapacity)
				
					: 사용자가 직접 배열 크기를 정하면서 벡터를 만든다.
					
				4) Vector(int initialCapacity, int capacityIncrement)
				
					: 3)의 기능 + 데이터 양 증가 시 추가할 배열의 크기 정함
					
					  		
				
					+) 컬렉션은 데이터 양에 관계없이 항상 데이터를 입력받을 수 있다. (크기가 자동 증가)
					   
					   이 때 데이터 입력받을 공간을 확보해야 하는데 규칙은 현재공간 * 2가 된다.
					   
			
			
			벡터의 주요 함수
				
					
				1) 데이터 입력 함수
				
					: add(Object obj)//자바에서 사용하는 모든 데이터 입력 가능한 함수
					  
					  add(int index, Object element)
					  
					  addAll(Collection c)//다른 컬렉션에 있는 데이터 모두 입력 가능
					  
					  addAll(int index, Collection c)
					  
					  addElement(Object obj)
					  
					  insertElementAt(Object obj, int index)
					  				
					  				
					  ==> 모두 기능은 같으나 매개변수만 다를 뿐				
					  				
					  				
					  				
				2) 데이터 수정 함수  :  해당 위치 데이터를 다른 데이터로 교체
				
					: set(int index, Objcet element)
					  
					  setElementAt(Object obj, int index)
					  
					  		
				3) 데이터 꺼내는 함수		   
					
					get(int index)
					
					elementAt(int index)
					
					firstElement() : 첫번째 요소가 뭔가?
					
					lastElement()
					
					elements()
					
					
			
				+) E, V, K라고 표현한 것은 Object를 의미하는 제너릭스 용어이다.
					Object 타입 데이터라고 이해하면 된다.
					

			
				
		2. ArrayList : Vector의 신버전, 배열 형태로 데이터를 관리하기 때문에 벡터의 특징을 그대로 가진다.
					   하지만 스레드에서 동기화 처리를 자동으로 해주기에 벡터보다는 ArrayList를 선호						  
					  
			
			사용법 : 벡터와 유사
			
			
		 *	+) List 계열의 주소(변수)를 출력하면 마치 데이터가 나온 것처럼 보이지만 
			   이것은 toString()를 오버라이딩 해놔서 반환된 문자열을 출력만 해주는 것
			   따라서 절대로 데이터를 사용하는 개념은 아니다.   
			   
			
			
		3. LinkedList : 내부적으로 이중 연결 리스트 방식으로 데이터를 보관하는 컬렉션	
				
				
				장점 : 데이터를 중간에 끼워넣는 작업, 삭제 작업은 속도가 빠르다.
			
				단점 : 데이터 누적시키는 작업은 느림
				
				
				==> 데이터 변화 심한 경우 많이 사용
				
				
		  	+) 참고 클래스
		  	
		  		1) Iterator : 한 가지 방법으로 데이터를 꺼내기 위한 클래스
		  		
		  		
		  					  컬렉션은 클래스의 집합이며 그 형태도 각각 다르다.
		  					  하지만 이들은 서로 혼용될 수 있다.
		  					  그런데 데이터 꺼내는 방식은 약간씩 다르다.					
							  List에서 데이터를 꺼내는 방식과 Set에서 데이터를 꺼내는 방식이 다르다.
							  (꺼내는 소스를 다르게 만들어야 한다는 의미)
							  
							  그래서 데이터를 꺼내기 위해서만 사용하는 클래스를 따로 만들어 놨다.
							  이것이 Iterator 클래스
							  List, Set 계열 모두 Iterator로 변환만 시키면 한 가지 방식으로 데이터를 꺼낼 수 있다.
							  								  
						
						
						특징 (=StringTokenizer)

							- 순차적으로만 꺼냄
							
							- 한 번 꺼낸 데이터는 자동 삭제					
				
							
				 2) Collections : 이 클래스는 이름은 컬렉션이지만 컬렉션의 기능은 없고 컬렉션을 이용할 때 
				 				  필요한 부가적인 기능들을 제공하는 유틸리티 클래스
				 				  
				 				  	   
						주의
						
							- 매개변수에서 List 요구하면 List 계열을, Set 요구하면 Set 계열을 주면 된다. 	   
							- Collection을 요구하면 List나 Set 중 하나를 주면 된다.
							- Map을 요구하면 Map을 주면 된다.
							
						
						+) 일반적인 정렬(sort)은 오름차순, 만약 정렬 방식을 변경하고 싶다면 
						   sort(List list, Comparator c)를 사용
						
						
		
		<Set 계열> 
			
			특징 
				
				1. 입력 순서 보장 x
					입력 순서가 아니라 나름의 규칙에 따라 데이터 보관
					 외부에서 접근이 불가능하기에 꺼내는 함수가 따로 없다.
				
				2. 중복 데이터 허용 x	 
					중복 데이터는 한 번만 저장, 같은 데이터가 입력되면 먼저 데이터를 지우고 새로운 데이터로 입력한다.
					 

			종류
			
				1. HashSet : HashCode를 이용해 정렬해서 보관하는 컬렉션 (일반적인 정렬 아님)
				
					+) Set 계열의 컬렉션은 꺼내는 함수가 없음
						=> 개발자가 데이터가 저장된 장소를 모르기에 특정 위치를 지정할 수 없다.
						   
						1) Iterator로 변환해서 순서대로 꺼내서 사용
						2) List 계열로 변환해서 인덱스 사용해서 꺼냄
						
						
						
						List는 입력 순서대로 차곡차곡 쌓는다. 인덱스와 데이터를 동시에 기억한다.
						Set은 인덱스가 없어서 데이터의 위치를 알 수 없다. 데이터 보관의 기능만 한다.
						Map은 인덱스 대신 키값을 사용, 인덱스와 키값을 동시에 기억한다. 
						
			
				2. TreeSet : 내부적으로 Tree Sort라는 알고리즘을 이용해서 데이터를 보관하는 컬렉션
				
					
					특징
					
						- 일반적인 정렬방식 사용 (오름차순)
					
					
					생성 방법
					
						- TreeSet(Comparator comparator)	
							
							: 정렬 방식을 변경해서 TreeSet을 만든다.					
							
							TreeSet() : 정렬 가능한 데이터들만 입력 가능 (숫자), 객체 타입은 넣을 수 없다.(크기 비교가 불가능하니까)
							
						- TreeSet(SortedSet<E> s)
							
							: TreeSet을 사용해서 다시 TreeSet을 만든다.
							
					
					+) 참고 함수
					   
					   subSet() : 하나의 Set에 담긴 내용 중 특정 부분만 골라서 새로운 Set을 만드는 함수
					
					   headSet(E toElement) : 처음부터 지정한 부분까지 골라서 새로운 Set을 만드는 함수
					   
					   tailSet(E fromElement) : 지정한 부분에서부터 마지막까지 골라서 새로운 Set을 만드는 함수	
					   
					   
					   
	 	
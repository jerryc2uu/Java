# day16

<Map 계열> : 하나의 데이터를 그 데이터를 구분할 수 있는 키값과 한 쌍으로 만들어서 기억하는 컬렉션
			 키값을 사용해서 데이터를 꺼낸다.
			 많은 데이터를 보관하는 용도보다는 적은 양의 데이터를 손쉽게 구분하여 사용할 목적으로 사용됨
			 
			 배열이나 list는 인덱스가 있고 꺼낼 수 있음, set은 인덱스는 있지만 개발자는 알 수가 없음, map은 인덱스 대신 키값을 개발자가 정해서 씀 		
	
	
	
	1. HashMap : 신 버전에서 나온 클래스, 사용 권장됨
	 
			HashTable : 구 버전에서 나온 클래스, 
	
			내부적으로 키값으로 정렬할 때 해쉬테이블을 이용해서 보관
	
			(키값으로 정렬할 때 기준이 해쉬코드)
	
			해쉬맵은 키셋만, 해쉬테이블은 키셋이랑 키 모두 가능
  				맵의 데이터는 키값으로 정렬하는 거고 데이터로 정렬하는 게 아님
 		
	
			주요 함수
			
				1. put(Object key, Object value) : 데이터 입력
				
				2. get(Object key) : 데이터 꺼냄
					
				3. values() : 데이터들만 꺼냄
				
				4. keys() = keySet() : 키값들만 꺼냄 (반환값이 set, 키값은 중복해서 쓰면 안 된다.)
				
				
				+) keys()로 꺼낸 데이터는 Enumeration으로 반환(이 클래스는 Iterator의 구 버전)
					즉, 데이터를 순차적으로 꺼낼 수 있는 클래스이며 1회 사용 후 소멸
					
				+) HashMap에서는 키값만 꺼내는 함수가 keySet()으로 변경되었다.	
					
					
				//모르겠으면 넘어갈 것	
				+) entrySet() : Map은 반드시 키값을 알아야 꺼낼 수 있지만 이 함수를 이용하면 다른 방식으로 꺼낼 수 있다.	
								키값과 데이터를 Set으로 묶어주는 함수
								문제는 Map은 항상 키값과 데이터 두 개가 있어야만 저장이 되지만, 
								Set은 오직 한 개만 저장된다는 점이다.
								따라서 키값과 데이터를 하나로 묶어야만 Set에 저장이 된다는 뜻이다. 
			
								어떻게 묶는가?
								VO 클래스 (데이터 전달용으로만 쓰는 클래스)로 묶는다. ex) 지금까지 만든 Student 클래스
								이 클래스가 바로 Map.Entry 클래스다.(Map 클래스 안에 Entry 클래스를 또 만듦)
								이 클래스 안에는 Key와 Value 변수가 은닉화되어 있고 이 변수를 사용할 수 있도록 함수를 제공하고 있다.
								두 변수를 하나로 묶어놓은 클래스가 Map.Entry 클래스다.
								Map.Entry 갯수 = Map에 들어간 데이터의 갯수
						
		
		2. TreeMap : TreeSet과 마찬가지로 내부에서 알아서 정렬하면서 데이터를 기억하는 Map.
					 정렬 기준으로 키값을 이용.
					 따라서 키값이 정렬되지 않는 클래스를 사용할 수 없고 필요하다면 정렬 방식을 정해서 사용해야 한다.
					   
										
			+) 기능이 필요해서가 아니라 여러 개의 데이터를 하나로 묶기 위한 목적으로 만들어진 클래스가 있다.
			
				class Tmp {
					String name;
					int age;
					
				}
				
				이런 클래스를 우리는 데이터 빈 클래스라고 부르고 Value Object(VO) 클래스라고도 부른다.
				또는 이런 클래스들은 데이터를 전달할 목적으로 사용되므로 DTO(Data Transfer Object)라고도 부른다.
				map.entry도 vo 클래스(value와 key 변수만 갖는)
						
			
			+) 컬렉션 안에는 다시 컬렉션을 입력할 수 있다.(중첩 가능) 
			   
			   ex) ArrayList 안에 Map이나 Set이 들어갈 수 있다!
			  
			   컬렉션 안에는 모든 클래스를 입력할 수 있으므로 클래스의 일종인 컬렉션도 저장이 가능한 것
		
		
		
			
		3. Properties : Map의 역할을 하는 클래스
						일반 Map과 차이점은 파일(외부장치)을 이용해서 직접 데이터를 읽어서
						Map처럼 저장할 수 있고 Map에 저장된 데이터를 직접 파일로 출력해서 저장할 수 있다.			
		
		
						주의 ] 파일의 내용 읽을 때 인코딩 되지 않는다.
						       한글 파일의 경우 파일 자체에서 인코딩하지 않으면 내용이 한글인 경우 한글이 깨져서 들어온다.
						       (MS-949)
		
		
						       
						+) 한글이 포함된 파일을 Properties에서 사용하기 위해 인코딩하는 방법
						
						  1) cmd 창을 연다.
						  2) path에 JAVA_HOME이 등록되어 있는지 확인하고
						  3) native2ascii 명령을 사용해서 인코딩한다.
						  
						  	형식 : native2ascii		현재파일	새로운파일     
						       
							ex) native2ascii   d:\sample.txt 	d:\sample_ko.txt					 

							
						+) Properties 클래스는 오직 String으로만 키값과 데이터를 처리해야 한다.	
						
						+) Properties는 또 하나의 특징을 갖고 있는데, 현재 프로그램의 정보를 Map으로 자동처리하는 기능을 갖고 있다.
							(현재 시스템이나 정보를 Map의 형태로 꺼낼 수 있다는 뜻)
		
		
		
		
		==> 컬렉션에 넣은 데이터는 Object 타입으로 자동형변환된다.
		    꺼내 쓸 때는 언제나 강제형변환이 필요하다.
			그런데 이게 귀찮다. 그래서 생겨난 것이? 제너릭스
			
-----------------

			
	<제너릭스> : 컬렉션에 입력되는 데이터를 미리 알려줘서 형변환 없이 사용할 수 있도록 해주는 방법 
				(컬렉션에 입력되는 데이터를 강제하는 것)
	
	
				 컬렉션은 모든 형태의 데이터를 다 입력받을 수 있다.
				 하지만 실무에서는 한 가지 형태로 데이터를 입력받는 것을 원칙으로 한다.
				 꺼낼 때 항상 강제형변환 해줘야 한다. 					
				 즉, 한 가지 형태로 결정해서 데이터를 입력해놨는데 꺼낼 때는 자동형변환이 일어나지 않기 때문에
				 항상 강제 형변환을 해줘야 한다.
					
					 
			형식 : ArrayList<String> list = new ArrayList<String>(); ==> 문자열만 입력 가능
					 
					 
			+) 제너릭스는 전파되지 않는다.
			   하나의 컬렉션이 제너릭스 선언되었더라도 그 컬렉션을 이용하는 다른 컬렉션은 제너릭스를 잊어버리게 된다.
			   결국 새로운 컬렉션도 다시 제너릭스 선언을 해줘야 한다.
			
			
			+) 특수한 제너릭스 : 
				
				원래 제너릭스는 특정 클래스만 입력받을 목적으로 사용된다.
				
					형식 : <? super 클래스이름> ==> 지정한 클래스 포함해서 상위 클래스까지 허락한다.
						   <? extends 클래스이름> ==> 지정한 클래스 포함해서 하위 클래스까지 허락한다.	    		
						   
						   
						   ==> 제너릭스 선언을 하지 않은 것과 동일한 효과가 있다.
						   	   왜냐하면 형변환을 해줘야 하기 때문
						   	   
--------------

	<어노테이션> : 내부적으로 약속된 실행을 자동으로 처리하도록 하는 명령
	
					화면에 실제 보이는 실행이 아니고 점검이나 선언적인 실행(이 클래스는 어떻게 동작하세요)의 의미를 가진 명령	
					
			형식 : @명령   	   
				
				ex) @Override
				

--------------

					